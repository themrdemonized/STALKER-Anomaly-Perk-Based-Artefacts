-- Perk Based Artefacts

-- Provides special perks and unique properties to junk artefacts
-- Beyond boundaries of traditional stats

-- Inspired by Fallout, Borderlands, Dark Souls games and Stalker mods like Golden Sphere (Золотой шар) and others
-- Written by demonized

-- Get psy table to manipulate psy health values
local actor_psy_table = {}
function get_actor_psy_table()
	if is_not_empty(actor_psy_table) then return end

	local m_data = alife_storage_manager.get_state()
	arszi_psy.save_state(m_data) 
	actor_psy_table = m_data.psy_table
end

function get_psy_health()
	if actor_psy_table.actor_psy_health then
		return actor_psy_table.actor_psy_health
	end
end

function set_psy_health(amount)
	if actor_psy_table.actor_psy_health then
		actor_psy_table.actor_psy_health = amount <= 1 and amount or 1
	end
end

function change_psy_health(amount)
	if actor_psy_table.actor_psy_health then
		set_psy_health(actor_psy_table.actor_psy_health + amount)
	end
end

local CreateTimeEvent = demonized_time_events.CreateTimeEvent
local RemoveTimeEvent = demonized_time_events.RemoveTimeEvent
local ResetTimeEvent = demonized_time_events.ResetTimeEvent

local add_cam_effector = level.add_cam_effector
local add_pp_effector = level.add_pp_effector
local set_pp_effector_factor = level.set_pp_effector_factor
local disable_input = level.disable_input
local enable_input = level.enable_input
local get_start_time = level.get_start_time
local get_time_factor = level.get_time_factor
local get_time_hours = level.get_time_hours
local get_time_minutes = level.get_time_minutes
local iterate_nearest = level.iterate_nearest
local level_name = level.name
local level_object_by_id = level.object_by_id
local press_action = level.press_action
local remove_cam_effector = level.remove_cam_effector
local remove_pp_effector = level.remove_pp_effector

local get_weather_manager = level_weathers.get_weather_manager

local get_game_time = game.get_game_time
local translate_string = game.translate_string

local is_critical_bone = perk_based_artefacts_bone_mapper.is_critical_bone

local ceil = math.ceil
local floor = math.floor
local max = math.max
local min = math.min
local random = math.random

local string_find = string.find
local string_gsub = string.gsub

local dump = string.dump
local load = loadstring
local unpack = unpack

local table_insert = table.insert
local table_remove = table.remove
local table_sort = table.sort

local tg = 0 --time_global storage used for actor on update limiter
local actor_on_update_timer = 0.1 -- on update limiter, every 100ms actor_on_update is triggered
local actor_on_update_time = 0

local tg_lag = 0 --stores the time_global on game start and then used to correct timers for loaded time effects

local time_elapsed = 0 -- Time from game start used for effects and cooldowns
local time_factor = 6
local saved_time_elapsed = 0 -- time_elapsed at the end of update

local actor_is_dying = false

local actor_level -- Current actor level

hud_state = 1

local actor_last_money = 0

local c_id_ppe = {
	actor_death = 445,
	black_infinite = 5606,
	blur = 5600,
	rcom_actor_death_quick = 446,
	snd_shock = 5607,
	transmutate = 69420,
	phantom_star = 69421,
}

local last_hit
local last_npc_hit
local last_npc_hit_bone_index
local last_monster_hit
local last_monster_hit_bone_index

local indoor_levels = {
	jupiter_underground 	= true,
	l03u_agr_underground 	= true,
	l04u_labx18 			= true,
	l08u_brainlab 			= true,
	l10u_bunker 			= true,
	l12u_control_monolith 	= true,
	l12u_sarcofag 			= true,
	l13u_warlab 			= true,
	labx8				 	= true
}

-- MCM
function load_defaults()
	local t = {}
	local op = perk_based_artefacts_mcm.op
	for i, v in ipairs(op.gr) do
		if v.def ~= nil then
			t[v.id] = v.def
		end
	end
	return t
end

settings = load_defaults()

function load_settings()
	settings = load_defaults()
	if ui_mcm then
		for k, v in pairs(settings) do
			settings[k] = ui_mcm.get("perk_based_artefacts/" .. k)
		end
	end
	return settings
end

-- Utils
local function trace(str, ...)
	if settings.debug_mode then
		printf("Perk Based Artefacts: " .. str, ...)
	end
	-- printf("-
	-- зеленый

	-- printf("!
	-- красный

	-- printf("~
	-- желтый
end

local function trace_table(t)
	if settings.debug_mode then
		printf("Perk Based Artefacts: Table Print")
		print_r(t)
	end
end

function compare_arrays(t1, t2)
	if #t1 ~= #t2 then return false end
	for i = 1, #t1 do
		if t1[i] ~= t2[i] then return false end
	end
	return true
end

function insert_n_times(t, item, n)
	local n = n or 1
	for i = 1, n do
		table_insert(t, item)
	end
end

function get_random_array_element(t)
	return t[random(#t)]
end

function array_keys(t)
	local res = {}
	local res_count = 1
	for k, v in pairs(t) do
		res[res_count] = k
		res_count = res_count + 1
	end
	return res
end

function get_first_key(t)
	for k, v in pairs(t) do
		return k
	end
end

function get_random_key(t)
	return get_random_array_element(array_keys(t))
end

function get_random_element(t)
	return t[get_random_key(t)]
end

-- Linear inter/extrapolation
function lerp(a, b, f)
    if a and b and f then
        return a + f * (b - a)
    else
        return a or b or 0
    end
end

function distance_to_xz_sqr(a, b)
	if a.distance_to_xz_sqr then
		return a:distance_to_xz_sqr(b)
	end

	local va = a.x - b.x
	local vb = a.z - b.z
	return va * va + vb * vb
end

-- Check if dir2 is to the left of dir1
function angle_left_xz(dir1, dir2)
	local dir1 = vector():set(dir1.x, 0, dir1.z)
	local dir2 = vector():set(dir2.x, 0, dir2.z)
	local dir_res = vector():set(VEC_ZERO):crossproduct(dir1, dir2)
	return dir_res.y <= 0
end

-- Wrapper for AddUniqueCall that checks for time_global update before executing function
function throttle(func, tg_throttle)
	local tg = 0
	if not tg_throttle or tg_throttle == 0 then
		return function(...)
			local t = time_global()
			if t ~= tg then
				tg = t
				return func(...)
			end
		end
	elseif type(tg_throttle) == "function" then
		return function(...)
			-- If true - fire immediately
			if tg_throttle(tg) == true then
				return func(...)
			end

			-- If false/nil - don't fire
			if not tg_throttle(tg) then
				return
			end

			-- If number - throttle by that number
			local t = time_global()
			if t < tg then return end
			tg = t + tg_throttle(tg)
			return func(...)
		end
	else
		return function(...)
			local t = time_global()
			if t < tg then return end
			tg = t + tg_throttle
			return func(...)
		end
	end
end

function get_time_elapsed()
	--trace(get_time_factor())
	return floor(get_game_time():diffSec(get_start_time()) / time_factor * 10) * 0.1
end

function get_object_by_id(id) -- same as _g.script one but without spamming in console
	if not (id and type(id) == "number") then
		callstack()
		--printe("!ERROR get_object_by_id | id (%s) is invalid", id)
		return
	end

	if (id == AC_ID) then
		return db.actor
	end

	local obj = db.storage[id] and db.storage[id].object or level_object_by_id(id)
	if (not obj) then
		--printe("!ERROR get_object_by_id | no game object recieved from id (%s)", id)
		return
	end
	return obj
end

function se_clear_vars(id)
	local m_data = alife_storage_manager.get_state()
	if m_data.se_object[id] then
		m_data.se_object[id] = nil
		-- empty_table(m_data.se_object[id])
	end
end

function table2vec(t)
	return vector():set(t.x, t.y, t.z)
end

function vec2table(v)
	return {x = v.x, y = v.y, z = v.z}
end

function get_monster_clsid_and_kind(obj)
	return obj:clsid(), SYS_GetParam(0, obj:section(), "kind", 0)
end

function IsBinoc(sec)
	return 	SYS_GetParam(0, sec, "ammo_class", "") == "ammo_binoc"
	or 		SYS_GetParam(0, sec, "class", "") == "WP_BINOC"
end

function get_current_weather()
	return get_weather_manager():get_curr_weather()
end

function play_sound_on_actor(snd, volume, frequency, looped)
	if not snd then
		trace("snd is nil")
		return
	end
	local actor = db.actor
	local snd = xr_sound.get_safe_sound_object(snd)
	if snd then
		snd:play(actor, 0, looped and (sound_object.s2d + sound_object.looped) or sound_object.s2d)
		snd.volume = volume or 1
		snd.frequency = frequency or 1
		return snd
	end
end

local smoothed_values = {}

--EMA smoothing for changing values
local default_smoothing = 300
function ema(key, value, def, steps, delta)
	local steps = steps or default_smoothing
	local delta = delta or steps
	local smoothing_alpha = 2.0 / (steps + 1)

	smoothed_values[key] = smoothed_values[key] and smoothed_values[key] + min(smoothing_alpha * (delta / steps), 1) * (value - smoothed_values[key]) or def or value

	--printf("EMA fired, key %s, target %s, current %s, going %s", key, value, smoothed_values[key], (value > smoothed_values[key] and "up" or "down"))
	return smoothed_values[key]
end

function look_at_nearest_npc(npc, actor)
	local actor = actor or db.actor
	local npc = npc or utils_obj.get_nearest_stalker(actor)
	if npc then
		local npc_position = npc:bone_position("bip01_head")
		local actor_position = device().cam_pos
		local actor_direction = device().cam_dir

		local look_distance = actor_position:distance_to(npc_position)
		local look_position = vector():set(actor_position):add(actor_direction:mul(look_distance))

		look_position.x = ema("look_x", npc_position.x, look_position.x, 50, device().time_delta)
		look_position.y = ema("look_y", npc_position.y, look_position.y, 50, device().time_delta)
		look_position.z = ema("look_z", npc_position.z, look_position.z, 50, device().time_delta)

		actor:actor_look_at_point(look_position)
	end
end

function change_sleep(item)
	if game_difficulties.get_game_factor("sleep") then
		actor_status_sleep.actor_on_item_use(item)
	end
end

function change_thirst(item)
	if game_difficulties.get_game_factor("thirst") then
		actor_status_thirst.actor_on_item_use(item)
	end
end

function add_pp_effector_const_smooth(ppfile, id, looped, time)
	add_pp_effector(ppfile, id, looped)
	local factor = 0.0001
	local inc_per_update = 0.001 * (1 / time)
	set_pp_effector_factor(id, 0.005)
	CreateTimeEvent(ppfile, id, 0, function()
		factor = math.min(1, factor + inc_per_update * device().time_delta)
		trace("%s, %s, factor %s", ppfile, id, factor)
		set_pp_effector_factor(id, factor)
		return factor == 1
	end)
end

function remove_pp_effector_const_smooth(ppfile, id)
	RemoveTimeEvent(ppfile, id)
	remove_pp_effector(id)
end

-- Artefacts
local refresh_state
local force_refresh_state

local artefacts = {}
local belt = {}

-- Temporal virtual artefacts to add
-- Only adds if no artefacts of that type is on belt
virtual_artefacts = {}

function add_virtual_artefact(sec)
	if sec then
		virtual_artefacts[sec] = true
		refresh_artefacts(true)
	end
end

function remove_virtual_artefact(sec)
	if sec then
		virtual_artefacts[sec] = nil
		refresh_artefacts(true)
	end
end

-- Find artefact in a container
function get_artefact_from_container(sec)
    local sec = sec
    local cont
    if (string_find(sec, "(lead.-_box)",3)) then
        sec = sec:gsub("_lead_box", "")
        cont = "lead_box"
    elseif (string_find(sec, "(af.-_iam)",3)) then
        sec = sec:gsub("_af_iam", "")
        cont = "af_iam"
    elseif (string_find(sec, "(af.-_aac)",3)) then
        sec = sec:gsub("_af_aac", "")
        cont = "af_aac"
    elseif (string_find(sec, "(af.-_aam)",3)) then
        sec = sec:gsub("_af_aam", "")
        cont = "af_aam"
    end
    return sec, cont
end

function iterate_belt_function(owner, artefact, artefacts, belt)
	local sec = artefact:section()

	-- Find artefact in a container if its allowed in settings
	if settings.allow_arty_containers then
		sec = get_artefact_from_container(sec)
	end

	if artefacts[sec] then
		artefacts[sec].count = artefacts[sec].count + 1
		table_insert(artefacts[sec].ids, artefact:id())
		table_insert(artefacts[sec].names, artefact:name())
	else
		artefacts[sec] = {
			count = 1,
			ids = { artefact:id() },
			names = { artefact:name() }
		}
	end
	table_insert(belt, sec)
end

iterate_belt = function(actor)
	local artefacts = {}
	local belt = {}

	if has_alife_info("lucifer_active") then
		local af_lucifer = actor:object("af_lucifer")
		if af_lucifer then
			trace("lucifer exists, %s, %s", af_lucifer:id(), af_lucifer:name())
			artefacts.af_lucifer = {
				count = 1,
				ids = { af_lucifer:id() },
				names = { af_lucifer:name() }
			}
		else
			artefacts.af_lucifer = {
				count = 1,
				ids = {  },
				names = {  }
			}
		end
	end

	local function iterate_belt_f(owner, artefact)
		iterate_belt_function(owner, artefact, artefacts, belt)
	end
	actor:iterate_belt(iterate_belt_f)

	for k, v in pairs(virtual_artefacts) do
		if not artefacts[k] then
			artefacts[k] = {
				count = 1,
				ids = { },
				names = { }
			}
			table_insert(belt, k)
		end
	end

	table_sort(belt)
	return artefacts, belt
end

refresh_artefacts = function(force)
	trace("refresh artefacts triggered")
	local new_artefacts, new_belt = iterate_belt(db.actor)
	if force or not compare_arrays(belt, new_belt) then
		trace("artefacts are different, refreshing")
		artefacts = new_artefacts
		belt = new_belt
		return true
	end
	trace("artefacts are same")
	return false
end

-- For time events
refresh_artefacts_time_event_func = function(force)
	refresh_artefacts(force)
	return true
end

-- Callbacks
callbacks = {}
function register_callback(callback, callback_function, on_end_function, key)
	if key and callbacks[key] and callbacks[key].func then
		UnregisterScriptCallback(callbacks[key].callback, callbacks[key].func)
	end

	local t = {
		callback = callback,
		func = callback_function,
		on_end = on_end_function
	}

	local key = key or (#callbacks + 1)
	callbacks[key] = t
	trace("registering callback %s, key %s", callback, key)

	if callbacks[key].func then
		RegisterScriptCallback(callbacks[key].callback, callbacks[key].func)
	end

	return key
end

function register_on_equip_callback(callback, callback_function, on_end_function, key)
	register_callback(callback, callback_function, on_end_function, key .. "_on_equip")
end

function unregister_callback(key)
	if not callbacks[key] then return end
	trace("unregistering callback %s, %s", key, callbacks[key].callback)

	if callbacks[key].func then
		UnregisterScriptCallback(callbacks[key].callback, callbacks[key].func)
	end

	if callbacks[key].on_end then
		callbacks[key].on_end()
	end

	callbacks[key] = nil
end

function unregister_callbacks()
	for i, props in pairs(callbacks) do
		unregister_callback(i)
	end
end

function unregister_on_equip_callback(key)
	unregister_callback(key .. "_on_equip")
end

function unregister_on_equip_callbacks()
	for key, props in pairs(callbacks) do
		if string_find(key, "_on_equip$") then
			unregister_callback(key)
		end
	end
end

-- Effects
cooldowns = {} -- Table of cooldowns of artefacts (["artefact"] = time_elapsed + cooldown)
function add_cooldown(cooldown, name)
	trace("added cooldown, name %s, time %s, current_time %s", name, time_elapsed + (cooldown or 0), time_elapsed)
	cooldowns[name] = time_elapsed + (cooldown or 0)
end

function check_cooldown(name)
	if not cooldowns[name] then return true end
	if time_elapsed >= cooldowns[name] then
		cooldowns[name] = nil
		return true
	end
	trace("cooldown not expired yet, name %s, time %s, current_time %s", name, cooldowns[name], time_elapsed)
	return false
end

function remove_cooldown(name)
	cooldowns[name] = nil
end

status_effects = {} -- Table of status effects of artefacts (["artefact"] = time_elapsed + cooldown)
function add_status_effect(timer, effect, key, check_timer)
	if check_timer then
		if type(check_timer) == "number" then
			check_timer = clamp(check_timer, 0, 2)
			if check_timer == 0 then
				check_timer = false
			end
		end
	end

	if check_timer and status_effects[key] then
		local remaining_time = status_effects[key].timer - time_elapsed
		if check_timer == 2 then
			trace("can't add effect, already existing with timer")
			trace("effect %s, timer %s, remaining_time %s, new timer %s", key, status_effects[key].timer, remaining_time, timer)
			return
		elseif remaining_time > timer then
			trace("can't add effect, already existing with bigger timer")
			trace("effect %s, timer %s, remaining_time %s, new timer %s", key, status_effects[key].timer, remaining_time, timer)
			return
		end
	end

	local t = {
		timer = time_elapsed + (timer or 0),
		time_applied = time_elapsed,
		effect = effect
	}
	if key then
		status_effects[key] = t
	else
		table_insert(status_effects, t)
	end
	trace("added status_effect, key %s, time %s, current_time %s", key, time_elapsed + (timer or 0), time_elapsed)
end

function check_status_effect(key)
	if not status_effects[key] then
		-- trace("status_effect %s not exist", key)
		return false
	end
	if time_elapsed >= status_effects[key].timer then
		-- trace("status_effect %s expired", key)
		status_effects[key] = nil
		return false
	end
	trace("status_effect active, key %s, time %s, current_time %s", key, status_effects[key].timer, time_elapsed)
	return true
end

function get_status_effect_remaining_time(key, normalized)
	if not check_status_effect(key) then
		-- trace("status_effect %s not exist, return time 0", key)
		return 0
	end

	local res = normalized and (1 - normalize(time_elapsed, status_effects[key].time_applied, status_effects[key].timer)) or (status_effects[key].timer - time_elapsed)
	return res > 0 and res or 0
end

function remove_status_effect(key)
	if status_effects[key] then
		trace("removing status effect, key %s, time %s, current_time %s", key, status_effects[key].timer, time_elapsed)
		status_effects[key] = nil
	end
end

-- Table of current active effects, contains tables of these {
-- timer = time_elapsed + timer in seconds, how long effect will be applied
-- effect = function(), the function of the effect
-- effect_function - string, dump of effect function to store in m_data
-- effect_args - array, args to effect_function
-- on_end = function(), the function on the expiration of effect
-- on_end_function - string, dump of on_end function to store in m_data
-- on_end_args - array, args to on_end_function
-- key - string, custom key to set in timed_effects table, otherwise will be used first available one
-- not_save - boolean, do not save in mdata }
-- this is the complex function intended to have persistence between saves, moving to different maps and so on, use if needed
-- no upvalues are allowed in the functions, best to reference globals by _G. lookup
-- good practice is to make a wrapper function that calls actual function by its global path, that way all variables will be accessible normally
-- The precision for both cooldown and timed effects is 0.1 or 100ms, making more precise timer or timed effect is pointless
timed_effects = {}
function add_timed_effect(timer, effect_function, effect_args, on_end_function, on_end_args, key, not_save)
	trace("current_time %s, adding effect %s", time_elapsed, time_elapsed + (timer or 0))

	local effect_args = effect_args or {}
	local on_end_args = on_end_args or {}
	local effect = {
		timer = time_elapsed + (timer or 0),
		effect = effect_function and function()
			effect_function(unpack(effect_args))
		end,
		effect_function = effect_function and dump(effect_function),
		effect_args = effect_args,
		on_end = on_end_function and function()
			on_end_function(unpack(on_end_args))
		end,
		on_end_function = on_end_function and dump(on_end_function),
		on_end_args = on_end_args,
		save = not not_save
	}

	if key then
		timed_effects[key] = effect
	else
		table_insert(timed_effects, effect)
	end
end

-- This is the simpler version of the function above if you do not care about persistence and saving states
function add_simple_timed_effect(timer, effect_function, on_end_function, key)
	trace("current_time %s, adding effect %s", time_elapsed, time_elapsed + (timer or 0))

	local effect = {
		timer = time_elapsed + (timer or 0),
		effect = effect_function,
		on_end = on_end_function
	}

	if effect.on_end then
		trace("effect has on end function %s", effect.on_end)
	end

	if key then
		timed_effects[key] = effect
	else
		table_insert(timed_effects, effect)
	end
end

function remove_timed_effect(key, on_end)
	if not timed_effects[key] then return end
	trace("removing effect, key %s", key)
	if on_end and timed_effects[key].on_end then
		trace("removing effect, firing on end, key %s", key)
		timed_effects[key].on_end()
	end
	timed_effects[key] = nil
end

-- Processing the effects
-- Whatever lowest time is set for effect, it will be processed at least once on process cycle
local function process_timed_effects()
	for key, props in pairs(timed_effects) do
		if props.effect then
			props.effect()
		end
		trace("effect %s, timer %s, current_time %s", key, props.timer, time_elapsed)
		if props.timer < time_elapsed then
			trace("removing effect, effect timer %s, current_time %s", props.timer, time_elapsed)
			if props.on_end then
				props.on_end()
			end
			timed_effects[key] = nil
		end
	end
end

-- Stored UI functions
ui_funcs = {}
function add_ui_func(key, override, section, text_func, validate_func, icon_layers)
	if ui_funcs[key] and not override then return end
	ui_funcs[key] = {
		key = key,
		override = override,
		section = section,
		text_func = text_func,
		validate_func = validate_func,
		icon_layers = icon_layers,
	}

	local ui = perk_based_artefacts_ui_effects.GUI
	if not ui then return end
	
	ui:AddIndicator(key, override, section, text_func, validate_func, icon_layers)
end

function remove_ui_func(key)
	if ui_funcs[key] then
		local ui = perk_based_artefacts_ui_effects.GUI
		ui:RemoveIndicator(key)
		ui_funcs[key] = nil
	end
end

function pbaui_on_indicator_remove(key)
	ui_funcs[key] = nil
end

-- Save var to mdata
function mdata_save(key, val)
	key = "pba_vars_" .. key
	alife_storage_manager.get_state()[key] = val
end

function mdata_load(key)
	key = "pba_vars_" .. key
	return alife_storage_manager.get_state()[key]
end

speed_boosts = { -- Table of speed boosts for different artefacts
	af_peas = {
		name = "af_peas_boost",
		boost = 0.085
	},
	af_generator = {
		name = "af_generator_boost",
		boost = 0.05
	},
	af_kogot = {
		name = "af_kogot_boost",
		boost = 0.16
	},
	af_lucifer = {
		name = "af_lucifer_boost",
		boost = 0.160
	}
}

jump_boosts = { -- Table of jump boosts for different artefacts
	af_peas = {
		name = "af_peas_boost",
		boost = 0.12
	},
}

local add_speed = speed.add_speed
local remove_speed = speed.remove_speed
function remove_speed_boosts()
	for boost, props in pairs(speed_boosts) do
		remove_speed(props.name)
	end
end

local add_weight = weight.add_weight
local remove_weight = weight.remove_weight

local add_jump = jump.add_jump
local remove_jump = jump.remove_jump
function remove_jump_boosts()
	for boost, props in pairs(jump_boosts) do
		remove_jump(props.name)
	end
end

local weapon_modifiers = demonized_weapon_modifiers

function has_artefacts_for_prop(artefact)
	if not (artefact_props[artefact] and artefact_props[artefact].sections) then
		return false
	end

	for k, v in pairs(artefact_props[artefact].sections) do
		if artefacts[k] then
			return true
		end
	end

	return false
end

function get_first_artefact_for_prop(artefact)
	if not (artefact_props[artefact] and artefact_props[artefact].sections) then
		return
	end

	for k, v in pairs(artefact_props[artefact].sections) do 
		if artefacts[k] then
			return artefacts[k]
		end
	end
end

artefact_props = { -- Special props of artefacts that are used in processing
	af_fire_loop = {
		sections = {af_fire_loop = true},
	},
	af_atom = {
		sections = {af_atom = true},
		power_boost = 0.02,
		radiation_cure = -0.00005,
	},
	af_generator = {
		sections = {af_generator = true},
		charge_boost = 0.000015,
		charge_threshold = 0.05, -- Below this charge the item has no battery
	},
	af_kislushka = {
		sections = {af_kislushka = true},
		bleeding_cure_boost = 0.00165,
		satiety_drain = -0.00115,
	},
	af_signet = {
		sections = {af_signet = true},
		health_boost = 0.001,
		status_effect_time_increment = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			return 2 * artefact_count
		end,
		status_effect_time_max = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			return 240 + 60 * artefact_count
		end,
		ui_text_func = function(self)
			return ("T:%s"):format(ceil(get_status_effect_remaining_time("af_signet")))
		end,
		ui_validate_func = function(self)
			return check_status_effect("af_signet")
		end,
		timed_effect_health_boost = 0.0004,
		timed_effect_func = function(self)
			db.actor:change_health(self.timed_effect_health_boost)
			arszi_psy.manage_psy_health()
			arszi_psy.manage_psy_health()
			arszi_psy.manage_psy_health()
		end,
	},
	af_ear = {
		sections = {af_ear = true},
		sound = xr_sound.get_safe_sound_object("perk_based_artefacts\\heartbeat_pulse_loop"),
		sound_play = function(self)
			self.sound:play(db.actor, 0, sound_object.s2d + sound_object.looped)
		end,
		sound_stop = function(self)
			self.sound:stop()
		end,
		health_threshold = (function()
			local t = {}
			for artefact_count = 1, 5 do
				t[artefact_count] = 0.27 + 0.03 * artefact_count
			end
			return t
		end)(),
		health_boost = 0.0041
	},
	af_black_angel = {
		sections = {af_black_angel = true},
		dice_roll = 0,
		reflect_chance = (function() -- LUT with chances to trigger by artefact count
			local t = {}
			for artefact_count = 1, 5 do
				-- Parabolic curve
				-- Progression is 25 -> 40 -> 55 -> 65 -> 70
				t[artefact_count] = -1.875 * artefact_count^2 + 22.5 * artefact_count + 4.375
			end
			return t
		end)(),
		valid_hits = { -- Valid hit types to trigger
			[hit.fire_wound] = true
		}
	},
	af_medallion = {
		sections = {af_medallion = true},
	-- 	enemy_squad_member_ids = {},
	-- 	on_enemy_eval = function(obj, enemy, flags)  -- Force former companions to become enemies and shoot
	-- 		local _self = artefact_props.af_medallion
	-- 		if _self.enemy_squad_member_ids[obj:id()] and enemy:id() == AC_ID then
	-- 	        flags.override = true
	-- 			flags.result = true
	-- 		end
	-- 	end,
	-- 	npc_on_death_callback = function(npc, who)
	-- 		local _self = artefact_props.af_medallion
	-- 		_self.enemy_squad_member_ids[npc:id()] = nil
	-- 		if is_empty(_self.enemy_squad_member_ids) then
	-- 			trace("Medallion, former companions are dead")
	-- 			UnregisterScriptCallback("on_enemy_eval", _self.on_enemy_eval)
	-- 			UnregisterScriptCallback("npc_on_death_callback", _self.npc_on_death_callback)
	-- 		end
	-- 	end,
	-- 	register = function(self)
	-- 		if is_empty(self.enemy_squad_member_ids) then return end

	-- 		trace("Medallion, Registering former companions callbacks")
	-- 		trace_table(self.enemy_squad_member_ids)
	-- 		RegisterScriptCallback("on_enemy_eval", self.on_enemy_eval)
	-- 		RegisterScriptCallback("npc_on_death_callback", self.npc_on_death_callback)
	-- 	end,
	-- 	reflect_chance = (function() -- LUT with chances to trigger by artefact count
	-- 		local t = {}
	-- 		for artefact_count = 1, 5 do
	-- 			-- Parabolic curve
	-- 			-- Progression is 35 -> 50 -> 62 -> 70 -> 75
	-- 			t[artefact_count] = round((20 - 1.66667 * artefact_count) * artefact_count + 16.6667) + 5
	-- 		end
	-- 		return t
	-- 	end)(),
	-- 	valid_hits = { -- Valid hit types to trigger
	-- 		[hit.fire_wound] = true
	-- 	}
	},
	af_lighthouse = {
		sections = {af_lighthouse = true},
		sounds = {
			"perk_based_artefacts\\TELEPRT1",
			"perk_based_artefacts\\TELEPRT2",
			"perk_based_artefacts\\TELEPRT3"
		},
		max_fov = 150,
		min_tf = 0.5,
		init_time = 0.2,
		restore_time = 3.5,
		active = false,
		cooldown_time = 30,
		cooldown_name = "af_lighthouse",
		npc_stun_radius = 4,
		npc_stun_anims = {
		    "norm_2_critical_hit_torso_0", -- good
		    "norm_1_critical_hit_head_0", -- good
		},
		ui_text_func = function(self)
			return ("C:%s"):format(ceil(cooldowns[self.cooldown_name] - time_elapsed))
		end,
		ui_validate_func = function(self)
			return not check_cooldown(self.cooldown_name)
		end,
		-- Saved vars
		fov = nil,
		hud_fov = nil,
		npc_stun = function(self, pos, stun_and_attack)
			level.iterate_nearest(pos, self.npc_stun_radius, function(npc)
				if npc:id() ~= AC_ID and IsStalker(npc) and npc:position():distance_to(pos) < self.npc_stun_radius and (stun_and_attack or xr_combat_ignore.is_enemy(npc, db.actor)) then
					if npc:movement_type() == move.walk or npc:movement_type() == move.run then
				        npc:set_movement_type(move.stand)
				    end
				    npc:play_cycle(get_random_array_element(self.npc_stun_anims), true)
				    state_mgr.set_state(npc, "idle")
				    if stun_and_attack then
				    	local s_hit = hit()
						s_hit.bone = "bip01_spine"
						s_hit.power = 0.05
						s_hit.draftsman = db.actor
						s_hit.type = hit.strike
						s_hit.direction = VEC_Z

						npc:hit(s_hit)
						return true
				    end
				end
			end)
		end,
		actor_net_destroy = function(self)
			RemoveTimeEvent("af_lighthouse", "af_lighthouse_0")
			RemoveTimeEvent("af_lighthouse", "af_lighthouse_1")
			RemoveTimeEvent("af_lighthouse", "af_lighthouse_2")
			RemoveTimeEvent("af_lighthouse_tp_prehit", 0)
			RemoveTimeEvent("af_lighthouse_tp", 0)
			if self.fov and self.hud_fov then
				exec_console_cmd("fov " .. self.fov)
				exec_console_cmd("hud_fov " .. self.hud_fov)
				exec_console_cmd("time_factor 1")
			end
		end,
		on_death = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, who, last_npc_hit, last_npc_hit_bone_index, stun_and_attack)
			if not check_cooldown(self.cooldown_name) then
				trace("Lighthouse, on cooldown")
				return
			end
			trace("Teleporting actor")

			local npc_pos = npc:position()

			-- Time event hell
			-- Put everything in next frame TE so if that fails, nothing will happen
			CreateTimeEvent("af_lighthouse", "af_lighthouse_0", 0, function()
				local fov = get_console_cmd(2, "fov")
				local hud_fov = get_console_cmd(2, "hud_fov")
				self.fov = fov
				self.hud_fov = hud_fov
				local mult = self.max_fov / fov
				local start_tg = time_global()
				local init_tg = time_global() + self.init_time * 1000
				local restore_tg = init_tg + self.restore_time * 1000

				add_pp_effector("black_infinite.ppe", c_id_ppe.black_infinite, true)
				set_pp_effector_factor(c_id_ppe.black_infinite, 0.005)

				self.active = true

				local function aond()
					self:actor_net_destroy()
				end
				RegisterScriptCallback("actor_on_net_destroy", aond)

				CreateTimeEvent("af_lighthouse", "af_lighthouse_1", 0, function()
					local tg = time_global()
					local k = min(1, normalize(tg, start_tg, init_tg))
					local new_fov = lerp(fov, self.max_fov, k)
					local new_hud_fov = clamp(hud_fov * (new_fov / fov), 0.1, 1)

					exec_console_cmd("fov " .. new_fov)
					exec_console_cmd("hud_fov " .. new_hud_fov)
					set_pp_effector_factor(c_id_ppe.black_infinite, k ^ 2.5)

					if k == 1 then
						actor:set_actor_position(npc_pos)

						add_cooldown(self.cooldown_time, self.cooldown_name)
						add_ui_func(
							self.cooldown_name,
							false,
							artefact,
							function() return perk_based_artefacts.artefact_props.af_lighthouse:ui_text_func() end,
							function() return perk_based_artefacts.artefact_props.af_lighthouse:ui_validate_func() end
						)

						exec_console_cmd("time_factor " .. self.min_tf)
						play_sound_on_actor(get_random_array_element(self.sounds), 0.7, random_float(0.95, 1.05))
						self:npc_stun(npc_pos, stun_and_attack)

						CreateTimeEvent("af_lighthouse", "af_lighthouse_2", 0, function()
							local tg = time_global()
							local k = min(1, normalize(tg, init_tg, restore_tg))
							local new_fov = lerp(fov, self.max_fov, (1 - k) ^ 4)
							local new_hud_fov = clamp(hud_fov * (new_fov / fov), 0.1, 1)
							local tf = lerp(self.min_tf, 1, k ^ 2)

							local weapon_modifier_k = 1 / tf
							weapon_modifiers.add_modifier("af_lighthouse", {
								SetRealRPM = weapon_modifier_k,
								SetModeRealRPM = weapon_modifier_k,
								anm_speed = weapon_modifier_k
							})

							exec_console_cmd("fov " .. new_fov)
							exec_console_cmd("hud_fov " .. new_hud_fov)
							set_pp_effector_factor(c_id_ppe.black_infinite, (1 - k) ^ 8)
							exec_console_cmd("time_factor " .. tf)

							if k == 1 then
								self.active = false
								remove_pp_effector(c_id_ppe.black_infinite)
								weapon_modifiers.remove_modifier("af_lighthouse")
								UnregisterScriptCallback("actor_on_net_destroy", aond)
								self.fov = nil
								self.hud_fov = nil
								return true
							end
						end)

						return true
					end
				end)

				return true
			end)
			return true
		end,
		manual_teleport = function(self, artefact, position, npc_target)
			-- Mock object
			local npc = {
				position = function(self)
					return position
				end
			}
			if self:on_death(db.actor, artefact, artefact_count, artefact_ids, artefact_names, npc, who, last_npc_hit, last_npc_hit_bone_index, npc_target) then

				-- Telefrag NPC
				if npc_target then
					trace("Beacon, telefrag %s", npc_target:name())
					
					CreateTimeEvent("af_lighthouse_tp_prehit", 0, self.init_time - 0.05, function()
						local s_hit = hit()
						s_hit.bone = "bip01_spine"
						s_hit.power = 0.01
						s_hit.draftsman = db.actor
						s_hit.type = hit.strike
						s_hit.direction = VEC_Z

						npc_target:hit(s_hit)
						return true
					end)

					CreateTimeEvent("af_lighthouse_tp", 0, self.init_time, function()
						local gibs = particles_object("new_effects\\krovisha_main")
						if gibs and not gibs:playing() then
							local p = npc_target:position():add(vector():set(0, 1.5, 0))
							local dir = device().cam_dir
							local h = dir:getH()
							local d = vector():setHP(h, 0)
							gibs:play_at_pos(p:mad(d, 0.3))
							local snd = xr_sound.get_safe_sound_object("perk_based_artefacts\\XDEATH" .. random(5))
							snd:play_at_pos(npc_target, position, 0, sound_object.s3d)
							snd.frequency = random_float(0.95, 1.05)
							snd.volume = 0.7
						else
							trace("gibs not found")
						end

						local sim = alife()
						sim:release(sim:object(npc_target:id()))

						local af_lucifer = artefact_props.af_lucifer
						if af_lucifer:check_lucifer() then
							af_lucifer:change_condition(0.06)
						end

						return true
					end)					
				end

				return true
			end			
		end,
	},
	af_cell = {
		sections = {af_cell = true},
		rad_amount_coeff = 0.1,
		reduction_coeff = (function() -- LUT with reduction coeffs by artefact count
			local t = {}
			for artefact_count = 1, 5 do
				-- Parabolic curve
				-- Progression is 15 -> 29 -> 42 -> 54 -> 65
				t[artefact_count] = round(-0.5 * artefact_count ^ 2 + 15.5 * artefact_count + 2.5) * 0.01
			end
			return t
		end)(),
		valid_hits = { -- Valid hit types to trigger
			[hit.fire_wound] = true
		}
	},
	af_elektron = {
		sections = {af_elektron = true},
		valid_hits = { -- Valid hit types to trigger
			[hit.shock] = true
		},
		sound_idle = xr_sound.get_safe_sound_object("perk_based_artefacts\\VIOLLOOP"),
		rpm_coeff = 1.25,
		min_rpm_coeff = 1.25,
		max_rpm_coeff = 3,
		max_speed_buff = 0.3,
		buff_time = 600,
		buff_time_rare = 1200,
		callbacks_registered = false,
		ui_text_func = function(self)
			return ("E:%s\\nT:%s"):format(
				round(normalize_100(self.rpm_coeff, self.min_rpm_coeff, self.max_rpm_coeff)),
				ceil(get_status_effect_remaining_time("af_elektron"))
			)
		end,
		ui_validate_func = function(self)
			return check_status_effect("af_elektron")
		end,
		on_weapon_fired = function(obj, wpn, ammo_elapsed, grenade_elapsed, ammo_type, grenade_type)
			local id = wpn:id()
			local af_elektron = artefact_props.af_elektron
			local c_obj = wpn:cast_Weapon()

			if not c_obj then return end

			local weapon_params = weapon_modifiers.get_saved_weapon_params(id)
			if not weapon_params then return end

			local steps = max(1, (weapon_params.RealRPM / 17) ^ 1.6)
			af_elektron.rpm_coeff = ema("af_elektron_rpm_coeff", af_elektron.max_rpm_coeff, af_elektron.rpm_coeff, steps)

			weapon_modifiers.add_modifier("af_elektron", {
				SetRealRPM = af_elektron.rpm_coeff,
				SetModeRealRPM = af_elektron.rpm_coeff,
				anm_speed = af_elektron.rpm_coeff
			})
		end,
		buff_func = function(self)
			db.actor:change_power(1)
			local speed_k = 1 + 0.3 * lerp(0.25, 1, normalize(self.rpm_coeff, self.min_rpm_coeff, self.max_rpm_coeff))
			add_speed("af_elektron_rpm_coeff", speed_k, false, true)
			add_speed("af_elektron_rpm_coeff", speed_k, true, true)

			-- Electron, reduce powerup
			self.rpm_coeff = ema("af_elektron_rpm_coeff", self.min_rpm_coeff, self.rpm_coeff, 100)
			trace("Electron, new coeff %s", self.rpm_coeff)

			weapon_modifiers.add_modifier("af_elektron", {
				SetRealRPM = self.rpm_coeff,
				SetModeRealRPM = self.rpm_coeff,
				anm_speed = self.rpm_coeff
			})

			if not self.callbacks_registered then
				self.callbacks_registered = true
				trace("Electron, registering callbacks")

				RegisterScriptCallback("actor_on_weapon_fired", self.on_weapon_fired)

				RemoveTimeEvent("af_elektron_sound_stop", 0)
				smoothed_values.af_elektron_rpm_coeff = nil
				smoothed_values.af_elektron_sound_stop = nil
				self.sound_idle:play(db.actor, 0, sound_object.s2d + sound_object.looped)
			end

			self.sound_idle.volume = lerp(0.2, 0.5, normalize(self.rpm_coeff, self.min_rpm_coeff, self.max_rpm_coeff))
			self.sound_idle.frequency = lerp(0.5, 1.5, normalize(self.rpm_coeff, self.min_rpm_coeff, self.max_rpm_coeff))
		end,
		buff_func_reset = function(self)
			trace("Electron, unregistering callbacks")

			self.callbacks_registered = false
			UnregisterScriptCallback("actor_on_weapon_fired", self.on_weapon_fired)
			weapon_modifiers.remove_modifier("af_elektron")
			remove_speed("af_elektron_rpm_coeff")			

			CreateTimeEvent("af_elektron_sound_stop", 0, 0, function()
				self.sound_idle.volume = 0.25
				local f = ema("af_elektron_sound_stop", 0.001, self.sound_idle.frequency, 50, device().time_delta)
				self.sound_idle.frequency = f
				if f < 0.02 then
					trace("Electron, stop sound")
					self.sound_idle:stop()
					return true
				end
			end)
		end,
		buff_func_time_effect = function()
			perk_based_artefacts.artefact_props.af_elektron:buff_func()
		end,
		buff_func_time_effect_reset = function()
			perk_based_artefacts.artefact_props.af_elektron:buff_func_reset()
		end,
	},
	af_tapeworm = {
		sections = {af_tapeworm = true},
		valid_hits = { -- Valid hit types to trigger
			[hit.wound] = true,
			[hit.strike] = true
		},
		monster_animations = { -- Animations to trigger on hit (WIP)
			stalker = {
			    "norm_2_critical_hit_head_0",
			    "norm_2_critical_hit_torso_0",
			    "norm_1_critical_hit_head_0",
			    "norm_1_critical_hit_torso_0",
			},
			[clsid.zombie_s] = {
				"_stand_idle_0",
				"_stand_idle_1",
				"_stand_idle_2",
			},
			[clsid.dog_s] = {
				"critical_hit_head_0",
				"critical_hit_head_1",
				"critical_hit_head_2",
				"critical_hit_torso_0",
				"critical_hit_torso_1",
				"critical_hit_torso_2",
			},
			-- [1] = {
			-- 	clsid.zombie_s,
			-- 	clsid.cat_s,
			-- 	clsid.dog_s,
			-- 	"SM_PIRANHA",
			-- },
			-- [2] = {
			-- 	clsid.boar_s,
			-- 	clsid.flesh_s,
			-- 	clsid.fracture_s,
			-- 	clsid.pseudodog_s,
			-- 	clsid.psy_dog_s,
			-- },
			-- [3] = {
			-- 	clsid.bloodsucker_s,
			-- 	clsid.snork_s,
			-- 	"SM_KARLIK",
			-- 	"SM_PSYSUCKER",
			-- 	"SM_LURKER",
			-- 	"SM_VOLK",
			-- 	"SM_POLTER_CORP",
			-- 	135, -- Borya
			-- },
			-- [4] = {
			-- 	clsid.burer_s,
			-- 	clsid.controller_s,
			-- 	"SM_TARK",
			-- },
			-- [5] = {
			-- 	clsid.chimera_s,
			-- 	clsid.gigant_s,
			-- 	"SM_MEDVED",
			-- 	"SM_MONSTER_BOAR",
			-- 	"SM_VENDIGO",
			-- 	131, -- Bibliotekar
			-- }
		},
		cooldown_name = "af_tapeworm",
		ui_text_func = function(self)
			return ("C:%s"):format(ceil(cooldowns[self.cooldown_name] - time_elapsed))
		end,
		ui_validate_func = function(self)
			return not check_cooldown(self.cooldown_name)
		end,
		iterate_func_radius = 3,
		effect_time = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, obj, amount, who, last_hit)
			return 1 + 2 * artefact_count
		end,
		iterate_func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, obj) -- Function to find nearest monster to trigger
			if IsMonster(obj) and obj.alive and obj:alive() and obj:position():distance_to_sqr(actor:position()) <= self.iterate_func_radius * self.iterate_func_radius then
				trace("Monster %s near Tapeworm, stun", obj:name())
				self:stun_func(actor, artefact, artefact_count, artefact_ids, artefact_names, obj, nil, obj)
				return true
			end
		end,
		stun_func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, obj, amount, who, last_hit)
			local who_id = who:id()
			local who_position = who:position()

			local s_hit = hit()
			s_hit.bone = "bip01_spine"
			s_hit.power = 0.05 * artefact_count
			s_hit.draftsman = who
			s_hit.type = hit.strike
			s_hit.direction = VEC_Z

			local effect_time = self:effect_time(actor, artefact, artefact_count, artefact_ids, artefact_names, obj, amount, who, last_hit)

			local monster_anims = self.monster_animations
			local monster_cls, monster_kind = get_monster_clsid_and_kind(who)

			local anims = IsStalker(who) and monster_anims.stalker or monster_anims[monster_kind] or monster_anims[monster_cls]

			local function ignore_enemy_function(obj, enemy, flags) -- Remove evaluation
				if obj:id() == who_id then
					flags.override = true
					flags.result = false
					return
				end
			end

			RegisterScriptCallback("on_enemy_eval", ignore_enemy_function)

			if IsStalker(who) then
				s_hit.power = s_hit.power * 0.1

				if who:id() == AC_ID then
					s_hit.draftsman = get_object_by_id(artefact_ids[1])
				end

				local function hit_enemy(time)
					who_position = who:position()

					local snd = xr_sound.get_safe_sound_object("anomaly\\electra_hit" .. get_random_array_element({"", "1"}))
					snd:play_at_pos(who, who_position, 0, sound_object.s3d)
					snd.frequency = random_float(0.95, 1.05)

					if who:alive() then
						who:set_movement_type(move.stand)
						who:set_body_state(move.standing)
						who:set_mental_state(anim.panic)
						who:hit(s_hit)

						if anims then
				        	who:play_cycle(get_random_array_element(anims), true)
				        end

						trace("time %s, hit %s, last_hit %s", time, s_hit.power, last_hit.power)
					else
						if who:get_physics_shell() then
							who:get_physics_shell():apply_force(random(1000, 2000), random(2000, 4000), random(1000, 2000))
						end
					end
					return true
				end

				for i = 0, effect_time, 0.05 do
					CreateTimeEvent("af_tapeworm" .. who_id, "af_tapeworm" .. who_id .. i, i, hit_enemy, i)
				end
			else
				local snd = xr_sound.get_safe_sound_object("anomaly\\electra_blast")
				snd:play_at_pos(who, who_position, 0, sound_object.s3d)
				snd.volume = 0.7
				snd.frequency = random_float(1.1, 1.2)

				local function hit_enemy(time)
					who_position = who:position()
					who:hit(s_hit)

					trace("time %s, hit %s", time, s_hit.power)
					return true
				end

				hit_enemy(0)
			end

			CreateTimeEvent("af_tapeworm" .. who_id, "af_tapeworm" .. who_id .. "eval", effect_time + 0.1, function()
				UnregisterScriptCallback("on_enemy_eval", ignore_enemy_function)
				return true
			end)

			add_cooldown(6, self.cooldown_name)
			add_ui_func(
				self.cooldown_name,
				false,
				artefact,
				function() return perk_based_artefacts.artefact_props.af_tapeworm:ui_text_func() end,
				function() return perk_based_artefacts.artefact_props.af_tapeworm:ui_validate_func() end
			)
		end,
	},
	af_sun = {
		sections = {af_sun = true},
		valid_hits = { -- Valid hit types to trigger
			[hit.fire_wound] = true,
			[hit.wound] = true,
			[hit.strike] = true
		},
		fire_damage = (function() -- LUT with chances to trigger by artefact count
			local t = {}
			for artefact_count = 1, 5 do
				-- Parabolic curve
				-- Progression is 50 -> 70 -> 85 -> 95 -> 100
				t[artefact_count] = ((27.5 - 2.5 * artefact_count) * artefact_count + 25) * 0.01
			end
			return t
		end)(),
		on_before_hit = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			if not check_lucifer() then
				trace("Sun, not under Lucifer effect")
				return
			end
			
			local fire_damage = self.fire_damage[min(5, artefact_count)]
			local fire_hit = hit(s_hit)
			fire_hit.type = hit.burn
			fire_hit.power = fire_hit.power * fire_damage
			fire_hit.draftsman = npc
			play_sound_on_actor("perk_based_artefacts\\fire" .. random(3), 0.8, random_float(0.6, 1))

			trace("Sun, Lucifer effect active, hitting with fire coeff %s, damage %s", fire_damage, fire_hit.power)
			npc:hit(fire_hit)

			local gibs = particles_object("artefact\\artefact_zharka")

			local npc_position = npc:position()
			npc_position.y = npc_position.y + 0.5

			if gibs and not gibs:playing() then
				gibs:play_at_pos(npc_position)
			end
		end,
		health_boost = 0.00035,
		power_clear_boost = 0.002,
		power_partly_boost = 0.001,
		power_not_clear_penalty = -0.001,
		eff = 0,
		ui_text_func = function(self)
			return self.eff
		end,
		ui_validate_func = function(self)
			for k, v in pairs(self.sections) do
				if artefacts[k] then
					return true
				end
			end
			return false
		end,
		ui_func = function(self, eff, artefact)
			add_ui_func(
				artefact,
				eff ~= self.eff,
				artefact,
				function() return perk_based_artefacts.artefact_props.af_sun:ui_text_func() end,
				function() return perk_based_artefacts.artefact_props.af_sun:ui_validate_func() end
			)
			self.eff = eff or 0
		end
	},
	af_peas = {
		sections = {af_peas = true},
		bleeding_cure_boost = 0.0015,
		moon_sleep_decrease = { -- Mock item to send to actor_status_sleep to decrease sleep
			sec = "moon_sleep_decrease",
			section = function(self)
				return self.sec
			end
		},
		moon_sleep_increase = { -- Mock item to send to actor_status_sleep to increase sleep
			sec = "moon_sleep_increase",
			section = function(self)
				return self.sec
			end
		},
		change_sleep = function(self, increase)
			local change = increase and self.moon_sleep_increase or self.moon_sleep_decrease
			if check_cooldown("af_peas_moon_sleep") then
				change_sleep(change)
				add_cooldown(10, "af_peas_moon_sleep")
			end
		end,
		eff = 0,
		ui_text_func = function(self)
			return self.eff
		end,
		ui_validate_func = function(self)
			for k, v in pairs(self.sections) do
				if artefacts[k] then
					return true
				end
			end
			return false
		end,
		ui_func = function(self, eff, artefact)
			add_ui_func(
				artefact,
				eff ~= self.eff,
				artefact,
				function() return perk_based_artefacts.artefact_props.af_peas:ui_text_func() end,
				function() return perk_based_artefacts.artefact_props.af_peas:ui_validate_func() end
			)
			self.eff = eff or 0
		end
	},
	af_kogot = {
		sections = {af_kogot = true},
		monster_to_meat = { -- Associations of meat chunk to its monster (clsid or kind)
			["SM_GERMAN_SHEPHERD"] 			= "mutant_part_dog_meat",
			["SM_FOX"] 	 					= "mutant_part_dog_meat",
			["SM_VOLK"] 	 				= "mutant_part_psevdodog_meat",
			["SM_TARK"] 	 				= "mutant_part_flesh_meat",
			["SM_MEDVED"]					= "mutant_part_flesh_meat",
			["SM_MONSTER_BOAR"]				= "mutant_part_boar_chop",
			["SM_VENDIGO"]					= "mutant_part_flesh_meat",
			["SM_CHICKEN"]					= "mutant_part_tushkano_meat",
			["SM_LURKER"] 					= "mutant_part_lurker_meat",
			["SM_PSYSUCKER"]				= "mutant_part_psysucker_meat",

			[clsid.bloodsucker] 			= "mutant_part_krovosos_meat",
			[clsid.bloodsucker_s] 			= "mutant_part_krovosos_meat",
			[clsid.boar] 					= "mutant_part_boar_chop",
			[clsid.boar_s] 					= "mutant_part_boar_chop",
			[clsid.chimera]					= "mutant_part_chimera_meat",
			[clsid.chimera_s]				= "mutant_part_chimera_meat",
			[clsid.dog_black]				= "mutant_part_dog_meat",
			[clsid.dog_red]					= "mutant_part_dog_meat",
			[clsid.dog_s]					= "mutant_part_dog_meat",
			[clsid.flesh]					= "mutant_part_flesh_meat",
			[clsid.flesh_s]					= "mutant_part_flesh_meat",
			[clsid.pseudodog_s]				= "mutant_part_psevdodog_meat",
			[clsid.psy_dog_s]				= "mutant_part_psevdodog_meat",
			[clsid.rat]						= "mutant_part_tushkano_meat",
			[clsid.rat_s]					= "mutant_part_tushkano_meat",
			[clsid.snork]					= "mutant_part_snork_hand",
			[clsid.snork_s]					= "mutant_part_snork_hand",
			[clsid.tushkano]				= "mutant_part_tushkano_meat",
			[clsid.tushkano_s]				= "mutant_part_tushkano_meat",
		},
		valid_hits = { -- Valid hit types to trigger
			[hit.wound] = true
		},
		dice_roll = 0,
		health_boost_coeff = 0.004,
		anims_to_accelerate = {
			anm_attack       = true,
			anm_attack2      = true,
			anm_attack2_e    = true,
			anm_attack_e     = true,
			anm_hide         = true,
			anm_show         = true,
			anm_show_empty   = true,
		},
		effect_time_trigger = 0,
		ui_text_func = function(self)
			return ("T:%s"):format(ceil(self.effect_time_trigger - time_elapsed))
		end,
		ui_validate_func = function(self)
			return time_elapsed < self.effect_time_trigger
		end,
		on_before_hit = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			if not self.valid_hits[s_hit.type] then
				trace("Claw, not a valid hit type %s", s_hit.type)
				return
			end

			local af_lucifer = artefact_props.af_lucifer
			local lucifer_bonus = max(1 - normalize(af_lucifer.condition, 0, 0.5), 0)

			s_hit.power = s_hit.power * (1 + artefact_count * 0.3) * (1 + lucifer_bonus)
			local health_boost = s_hit.power * self.health_boost_coeff * artefact_count

			add_simple_timed_effect(1, function()
				actor:change_health(health_boost)
			end)
			play_sound_on_actor("perk_based_artefacts\\HEADBRK" .. random(2), 0.3, random_float(0.8, 1.2))

			add_speed(speed_boosts.af_kogot.name, 1 + speed_boosts.af_kogot.boost * artefact_count, false, true)
			add_speed(speed_boosts.af_kogot.name, 1 + speed_boosts.af_kogot.boost * artefact_count, true, true)
			remove_timed_effect("af_kogot_boost", true)
			add_simple_timed_effect(4 + 1 * artefact_count, nil, function()
				remove_speed(speed_boosts.af_kogot.name)
			end, "af_kogot_boost")
			self.effect_time_trigger = time_elapsed + 4 + 1 * artefact_count
			add_ui_func(
				"af_kogot_boost",
				true,
				artefact,
				function() return perk_based_artefacts.artefact_props.af_kogot:ui_text_func() end,
				function() return perk_based_artefacts.artefact_props.af_kogot:ui_validate_func() end
			)

			self.dice_roll = random()
			if af_lucifer:check_lucifer() and self.dice_roll < (lucifer_bonus * lucifer_bonus) then -- Squared chance to have less proc on better condition
				s_hit.power = 10000
				play_sound_on_actor("perk_based_artefacts\\GNTEAR0" .. random(2), 0.75, random_float(0.9, 1.0))
			end
		end,
		on_death = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, monster, who, last_monster_hit, last_monster_hit_bone_index)
			local monster_id = monster:id()
			local monster_position = monster:position()
			local monster_direction = monster:direction()
			local monster_level_vertex_id = monster:level_vertex_id()
			local monster_game_vertex_id = monster:game_vertex_id()

			local af_lucifer = artefact_props.af_lucifer
			local lucifer_bonus = max(1 - normalize(af_lucifer.condition, 0, 0.5), 0)
			lucifer_bonus = lucifer_bonus * lucifer_bonus -- Squared chance to have less proc on better condition

			if af_lucifer:check_lucifer() and self.dice_roll < lucifer_bonus then
				trace("Overpowered Claw, dice_roll %s, chance %s", self.dice_roll, lucifer_bonus)
				local sim = alife()
				sim:release(sim:object(monster_id))
				local gibs = particles_object("new_effects\\krovisha_main")
				if gibs and not gibs:playing() then
					gibs:play_at_pos(monster_position)
					local snd = xr_sound.get_safe_sound_object("perk_based_artefacts\\XDEATH" .. random(5))
					snd:play_at_pos(monster, monster_position, 0, sound_object.s3d)
					snd.frequency = random_float(0.95, 1.05)
				else
					trace("gibs not found")
				end
				af_lucifer:change_condition(0.01)
			end

			local monster_cls, monster_kind = get_monster_clsid_and_kind(monster)
			local monster_meat = self.monster_to_meat[monster_kind] or self.monster_to_meat[monster_cls]
			if not (last_monster_hit and self.valid_hits[last_monster_hit.type] and monster_meat) then
				trace("Claw not triggered")
				return
			end

			local function spawn_meat()
				local meat_position = monster:position()
				local meat_direction = monster:direction()
				meat_direction = vector_rotate_y(meat_direction, random(-180, 180))
				meat_position.x = meat_position.x + meat_direction.x * random_float(0.5, 0.7)
				meat_position.y = meat_position.y + meat_direction.y + 1
				meat_position.z = meat_position.z + meat_direction.z * random_float(0.5, 0.7)
				local meat_item = alife_create_item(monster_meat, {meat_position, monster_level_vertex_id, monster_game_vertex_id, nil})
			end

			for i = 1, artefact_count do
				spawn_meat()
			end

			if af_lucifer:check_lucifer() and self.dice_roll < lucifer_bonus then
				for i = 1, 5 do
					spawn_meat()
				end
			end
		end
	},
	af_fonar = {
		sections = {af_fonar = true},
		blink_half_interval = 1400,
		min_radius = 1,
		max_radius = 4,
		light_sources = {}, -- Table of light sources
		targets = nil, -- Table of targets to light up
		on_item_take = function(item)
			local _self = artefact_props.af_fonar
			if not _self.targets then return end
			local id = item:id()
			if _self.targets[id] then
				_self.targets[id] = nil
				local light = _self.light_sources[id].light
				light.enabled = false
				light:update()
				_self.light_sources[id] = nil
			end
		end,
		light_sources_update = function()
			local _self = artefact_props.af_fonar
			if _self.targets == nil then
				local has_targets = false

				local rf_stashes = item_radio.RF_stashes or {}
				if rf_stashes[actor_level] then
					for id, freq in pairs(rf_stashes[actor_level]) do
						if not _self.targets then _self.targets = {} end
						_self.targets[id] = true
						has_targets = true
						trace("Lamp, adding stash %s", id)
					end
				else
					trace("Lamp, no active stashes on a level")
				end

				local rf_targets = item_radio.RF_targets or {}
				local sim = alife()
				local gg = game_graph()
				for id, v in pairs(rf_targets) do
					local se_obj = sim:object(id)
					if se_obj then
						local lvl = sim:level_name(gg:vertex(se_obj.m_game_vertex_id):level_id())
						if lvl == actor_level then
							if not _self.targets then _self.targets = {} end
							_self.targets[id] = true
							trace("Lamp, adding target %s", id)
							has_targets = true
						end
					end
				end

				if not has_targets then
					_self.targets = false
					trace("Lamp, no active targets on level")
				end
			end

			if _self.targets == false then
				return
			end

			for id, freq in pairs(_self.targets) do
				local obj = get_object_by_id(id)
				if obj then
					local tg = time_global()
					local light = _self.light_sources[id] and _self.light_sources[id].light or (function()
						trace("Lamp, creating light")
						local light = script_light() -- Create a light source
						light.type = 1 -- 1 = Point ; 2 = Spot
						light.range = 5 --1
						light.lanim = "koster_01_electra"
						light.lanim_brightness = 1
						light.hud_mode = false
						light.shadow = true -- Turn on/off
						light.volumetric = false
						light.enabled = true
						light.color = fcolor():set(0.7, 0.8, 1, 1)
						light:set_position(obj:position())
						light:set_direction(obj:direction())
						light:update()
						_self.light_sources[id] = {
							light = light,
							type = light.type,
							range = light.range,
							lanim = light.lanim,
							lanim_brightness = light.lanim_brightness,
							hud_mode = light.hud_mode,
							shadow = light.shadow,
							volumetric = light.volumetric,
							enabled = light.enabled,
							color = light.color,
						}
						return light
					end)()
					-- Periodic flashing
					local z = (tg % _self.blink_half_interval * 2) - _self.blink_half_interval
					local x = z * z
					local upper_limit = _self.blink_half_interval * _self.blink_half_interval
					light.range = normalize(x, 0, upper_limit) * _self.max_radius + _self.min_radius
					light:update()
				end
			end
		end
	},
	af_skull_miser = {
		sections = {af_skull_miser = true},
		money_items_num = 4,
		money_items = (function() -- Money items to choose and spawn
			local t = {}
			insert_n_times(t, "roubles", 85)
			insert_n_times(t, "money_10_50", 12)
			insert_n_times(t, "money_50_100", 8)
			insert_n_times(t, "money_100_200", 6)
			insert_n_times(t, "money_200_300", 5)
			insert_n_times(t, "money_300_400", 4)
			insert_n_times(t, "money_400_500", 3)
			insert_n_times(t, "money_500_600", 2)
			insert_n_times(t, "money_600_700", 1)
			insert_n_times(t, "money_700_800", 1)
			insert_n_times(t, "money_800_900", 1)
			insert_n_times(t, "money_900_1000", 1)
			return t
		end)(),
		head_bones = { -- NPC head bones for Miser's Skull perk
			[14] = true,
			[15] = true,
			[16] = true,
			[17] = true,
			[18] = true,
			[19] = true
		}
	},
	af_serofim = {
		sections = {af_serofim = true},
		invulnerability_time = 5,
		ironman_death_count = 0, -- Ironman compatibility
		ignore_all_damage_function = function(s_hit, bone_id, flags) -- "God Mode" function without g_god
			s_hit.power = 0.001
			s_hit.impulse = 0.001
		end,
		ignore_enemy_on_down_function = function(obj, enemy, flags) -- Remove evaluation for the down time
			if (enemy:id() == AC_ID) then
				flags.override = true
				flags.result = false
				return
			end
		end,
		effect_time_trigger = 0,
		ui_text_func = function(self)
			return ("T:%s"):format(ceil(self.effect_time_trigger - time_elapsed))
		end,
		ui_validate_func = function(self)
			return time_elapsed < self.effect_time_trigger
		end,
	},
	af_star_phantom = {
		sections = {af_star_phantom = true},
		weapon_hidden = false, -- Check for weapon is hidden
		hidden_num = 1,
		sound_start = xr_sound.get_safe_sound_object("perk_based_artefacts\\CTIMSTRT"),
		sound_idle = xr_sound.get_safe_sound_object("perk_based_artefacts\\CTIMLOOP"),
		sound_stop = xr_sound.get_safe_sound_object("perk_based_artefacts\\CTIMSTOP"),
		saved_volume_snd = 1,
		saved_volume_music = 1,
		degradation_rate = 0.00036,
		add_pp_effector = function(self)
			add_pp_effector_const_smooth("phantom_star.ppe", c_id_ppe.phantom_star, true, 0.7)
			self.sound_stop:stop()
			self.sound_start:play(db.actor, 0, sound_object.s2d)
			self.sound_start.volume = 1
			self.sound_idle:play(db.actor, 0, sound_object.s2d + sound_object.looped)
			self.sound_idle.volume = 1

			self.saved_volume_snd = level.get_snd_volume()
			level.set_snd_volume(self.saved_volume_snd * 0.33)

			if level.set_music_volume then
				self.saved_volume_music = level.get_music_volume()
				level.set_music_volume(self.saved_volume_music * 0.33)
			end
		end,
		remove_pp_effector = function(self)
			remove_pp_effector_const_smooth("phantom_star.ppe", c_id_ppe.phantom_star)
			self.sound_stop:play(db.actor, 0, sound_object.s2d)
			self.sound_stop.volume = 0.5
			self.sound_start:stop()
			self.sound_idle:stop()
			level.set_snd_volume(self.saved_volume_snd)
			if level.set_music_volume then
				level.set_music_volume(self.saved_volume_music)
			end
		end,
		hide_weapon = function(self)
			self.weapon_hidden = true
			self.hidden_num = self.hidden_num - 1
			db.actor:hide_weapon()
			trace("Phantom Star, weapon hidden, hidden_num %s", self.hidden_num)
		end,
		restore_weapon = function(self)
			self.weapon_hidden = false
			self.hidden_num = self.hidden_num + 1
			db.actor:restore_weapon()
			trace("Phantom Star, weapon restroed, hidden_num %s", self.hidden_num)
		end,
		reset_state = function(self)
			while self.hidden_num ~= 1 do
				trace("Phantom Star, resetting num, hidden_num %s", self.hidden_num)
				if self.hidden_num > 1 then
					self:hide_weapon()
				else
					self:restore_weapon()
				end
			end
			self.weapon_hidden = false
		end,
		ignore_enemy_function = function(obj, enemy, flags) -- Remove evaluation
			if (enemy:id() == AC_ID) then
				flags.override = true
				flags.result = false
				return
			end
		end,
		used_artys = nil,
		ui_text_func = function(self)
			if is_empty(self.used_artys) then return end

			local combined_condition = 0
			for _, id in ipairs(self.used_artys) do
				local obj = get_object_by_id(id)
				if obj then
					combined_condition = combined_condition + obj:condition() - 0.01
				end
			end

			local time = ceil(combined_condition / (self.degradation_rate * 10))
			return ("T:%s"):format(time)
		end,
		ui_validate_func = function(self)
			return is_not_empty(self.used_artys)
		end,
	},
	af_dragon_eye = {
		sections = {af_dragon_eye = true},
		trigger = false,
		cooldown_name = "af_dragon_eye",
		ui_text_func = function(self)
			return ("C:%s"):format(ceil(cooldowns[self.cooldown_name] - time_elapsed))
		end,
		ui_validate_func = function(self)
			return not check_cooldown(self.cooldown_name)
		end,
		on_before_hit = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			if not check_cooldown(self.cooldown_name) then
				trace("Dragon's Eye, on the cooldown")
				return
			end

			local current_weapon = actor:active_item()
			if not (current_weapon and not IsMelee(current_weapon)) then
				trace("Dragon's Eye, no current_weapon")
				return
			end			

			s_hit.power = 1000

			local next_time = (60 * 3) / (3 ^ (artefact_count - 1))
			add_cooldown(next_time, self.cooldown_name)
			add_ui_func(
				self.cooldown_name,
				false,
				artefact,
				function() return perk_based_artefacts.artefact_props.af_dragon_eye:ui_text_func() end,
				function() return perk_based_artefacts.artefact_props.af_dragon_eye:ui_validate_func() end
			)
			self.trigger = true
		end,
		on_death = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, who, last_npc_hit, last_npc_hit_bone_index)
			if not self.trigger then
				trace("Dragon Eye not triggered, on cooldown")
				return
			end
			self.trigger = false

			
			local npc_id = npc:id()
			trace("Victim's id: %s", npc_id)
			if npc_id == AC_ID then return end

			-- Slight delay for sound sync
			play_sound_on_actor("perk_based_artefacts\\SPHNEXP")
			CreateTimeEvent("af_dragon_eye_delay_explode", 0, 0.25, function()
				local npc_position = npc:position():add(vector():set(0, 1.5, 0))
				local npc_level_vertex_id = npc:level_vertex_id()
				local npc_game_vertex_id = npc:game_vertex_id()

				local function explode(explode_id)
					local explode_obj = get_object_by_id(explode_id)
					if explode_obj then
						trace("explode_obj spawned")
						local sim = alife()
						sim:release(sim:object(npc_id))
						explode_obj:explode(0)
						trace("explode obj exploded")
						local gibs = particles_object("new_effects\\krovisha_main")
						if gibs and not gibs:playing() then
							gibs:play_at_pos(npc_position)
							local snd = xr_sound.get_safe_sound_object("perk_based_artefacts\\XDEATH" .. random(5))
							snd:play_at_pos(npc, npc_position, 0, sound_object.s3d)
							snd.frequency = random_float(0.95, 1.05)
						else
							trace("gibs not found")
						end
						return true
					end
					trace("explode_obj not spawned yet")
					return false
				end

				local explode_obj = alife_create_item("ied_new_blow", {npc_position, npc_level_vertex_id, npc_game_vertex_id, nil})
				CreateTimeEvent(explode_obj.id, explode_obj.id, 0, explode, explode_obj.id)

				artefact_props.af_lucifer:change_condition(0.01)
				return true
			end)
		end,

		-- Special heli case
		on_heli_hit = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, who)
			if not check_cooldown(self.cooldown_name) then
				trace("Dragon's Eye, on the cooldown")
				return
			end

			if random() > 0.07 then
				trace("Dragon's Eye, heli not triggered")
				return
			end
			
			local npc_id = npc:id()
			trace("Victim's id: %s", npc_id)
			if npc_id == AC_ID then return end

			self.trigger = false

			-- Slight delay for sound sync
			play_sound_on_actor("perk_based_artefacts\\SPHNEXP")
			CreateTimeEvent("af_dragon_eye_delay_explode", 0, 0.25, function()
				local npc_position = npc:position()
				local npc_level_vertex_id = npc:level_vertex_id()
				local npc_game_vertex_id = npc:game_vertex_id()

				local function explode(explode_id)
					local explode_obj = get_object_by_id(explode_id)
					if explode_obj then
						trace("explode_obj spawned")
						explode_obj:explode(0)
						trace("explode obj exploded")

						-- Apply hit
						local s_hit = hit()
						s_hit.power = 1000
						s_hit.draftsman = db.actor
						s_hit.type = hit.strike
						s_hit.direction = VEC_Z
						npc:hit(s_hit)

						return true
					end
					trace("explode_obj not spawned yet")
					return false
				end

				local explode_obj = alife_create_item("ied_new_blow", {npc_position, npc_level_vertex_id, npc_game_vertex_id, nil})
				CreateTimeEvent(explode_obj.id, explode_obj.id, 0, explode, explode_obj.id)

				artefact_props.af_lucifer:change_condition(0.04)
				return true
			end)

			local next_time = (60 * 2) / (3 ^ (artefact_count - 1))
			add_cooldown(next_time, self.cooldown_name)
			add_ui_func(
				self.cooldown_name,
				false,
				artefact,
				function() return perk_based_artefacts.artefact_props.af_dragon_eye:ui_text_func() end,
				function() return perk_based_artefacts.artefact_props.af_dragon_eye:ui_validate_func() end
			)
		end,
		manual_explode = function(self, obj)
			local snd = xr_sound.get_safe_sound_object("perk_based_artefacts\\SPHNEXP")
			snd:play_at_pos(obj, obj:position(), 0, sound_object.s3d)

			local mass = obj:mass()
			obj:get_physics_shell():apply_force(0, mass * 19.62 * 50, 0)

			CreateTimeEvent("af_dragon_eye_delay_explode", 0, 0.25, function()
				local function explode(explode_id)
					local explode_obj = get_object_by_id(explode_id)
					if explode_obj then
						trace("explode_obj spawned")
						explode_obj:explode(0)
						trace("explode obj exploded")

						return true
					end
					trace("explode_obj not spawned yet")
					return false
				end

				local explode_obj = alife_create_item("ied_new_blow", {obj:position(), obj:level_vertex_id(), obj:game_vertex_id(), nil})
				CreateTimeEvent(explode_obj.id, explode_obj.id, 0, explode, explode_obj.id)

				artefact_props.af_lucifer:change_condition(0.05)

				alife_release_id(obj:id())
				return true
			end)
		end,
	},
	af_fountain = {
		sections = {af_fountain = true},
		cashback_triggered = false, -- Trigger flag to reset time event
		cashback_bonus = 0.08
	},
	af_ball = {
		sections = {af_ball = true},
		monster_tiers = { -- Monster Tiers opening by artefact count
			[1] = {
				clsid.cat,
				clsid.cat_s,
				clsid.dog_black,
				clsid.dog_red,
				clsid.dog_s,
				clsid.fracture,
				clsid.fracture_s,
				clsid.rat,
				clsid.rat_s,
				clsid.tushkano,
				clsid.tushkano_s,
				clsid.zombie,
				clsid.zombie_s,
				"SM_PIRANHA",
			},
			[2] = {
				clsid.bloodsucker,
				clsid.bloodsucker_s,
				clsid.boar,
				clsid.boar_s,
				clsid.flesh,
				clsid.flesh_s,
				clsid.pseudodog_s,
				clsid.psy_dog_s,
				clsid.snork,
				clsid.snork_s,
				"SM_PSYSUCKER",
				135, -- Borya
				"SM_LURKER",
			},
			[3] = {
				clsid.burer,
				clsid.burer_s,
				clsid.controller,
				clsid.controller_s,
				clsid.poltergeist,
				clsid.poltergeist_s,
				"SM_KARLIK",
				"SM_VOLK",
				"SM_POLTER_CORP",
				
			},
			[4] = {
				clsid.chimera,
				clsid.chimera_s,
				clsid.gigant_s,
				clsid.pseudo_gigant,
				"SM_MEDVED",
				"SM_MONSTER_BOAR",
				"SM_VENDIGO",
				131, -- Bibliotekar
				"SM_TARK",
			},
			[5] = {
				
			}
		},
		monsters = {}, -- Generated table to check if current monster is allowed to be kick
		cooldown_name = "af_ball",
		scan_radius = 2.7,
		ui_text_func = function(self)
			return ("C:%s"):format(ceil(cooldowns[self.cooldown_name] - time_elapsed))
		end,
		ui_validate_func = function(self)
			return not check_cooldown(self.cooldown_name)
		end,	
	},
	af_spaika = {
		sections = {af_spaika = true},
		weapon_shot = false,
		damage_multiplier = 1,
		event_reset = function(self)
			--trace("Spike: event reset")
			self.weapon_shot = false
			RemoveTimeEvent("af_spaika", "af_spaika_reset")
		end,
		stack_reset = function(self)
			--trace("Spike: stack reset")
			self.damage_multiplier = 1
			self.stacks = 0
			self:event_reset()
			--trace("Spike, weapon_shot %s", self.weapon_shot)
		end,
		psy_health_penalty_coeff = 0.17,
		psy_health_restore_coeff = 0.06,
		hit_buff_coeff = 0.05,
		critical_hit_buff_coeff = 0.15,
		stacks = 0,
		ui_text_func = function(self)
			return ("E:%s"):format(self.stacks)
		end,
		ui_validate_func = function(self)
			return self.stacks > 0
		end,
		effect_reset = function(self)
			if self.damage_multiplier > 1 then
				local s_hit = hit()
				s_hit.power = 0.005
				s_hit.type = hit.shock -- possible interference with Elektron and Sandstone, change to hit.telepatic if needed
				s_hit.draftsman = db.actor
				db.actor:hit(s_hit)
				change_psy_health(max(-0.9, (self.damage_multiplier - 1) * -self.psy_health_penalty_coeff))
				play_sound_on_actor("anomaly\\electra_hit1", 1, 1.5)
			else
				-- play_sound_on_actor("perk_based_artefacts\\quake3_hitsound", 0.75, 0.8)
			end
			self:stack_reset()
		end,
		bullet_groups = {},
		hitted_bullets = {},
		-- Iterate through bullet groups and insert all of bullets to work with shotguns
		add_bullet_group_to_hitted_bullets = function(self, bullet)
			for tg, t in pairs(self.bullet_groups) do
				for i, v in ipairs(t) do
					if v.bullet_id == bullet.bullet_id then
						for i, v in ipairs(t) do
							self.hitted_bullets[v.bullet_id] = v
						end
						return
					end
				end
			end
		end,
		remove_bullet_from_bullet_group = function(self, bullet)
			for tg, t in pairs(self.bullet_groups) do
				for i = #t, 1, -1 do
					local v = t[i]
					if v and v.bullet_id == bullet.bullet_id then
						table_remove(t, i)
					end
				end
				if is_empty(t) then
					self.bullet_groups[tg] = nil
				end
			end
		end,
		on_before_hit = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			local wpn = actor:active_item()
			if not (IsWeapon(wpn) and not IsMelee(wpn)) then return end 
			
			s_hit.power = s_hit.power * self.damage_multiplier
			trace("Spike, Final Damage %s, bonus %s", s_hit.power, self.damage_multiplier)
			play_sound_on_actor("perk_based_artefacts\\quake3_hitsound", 0.75, 1 + (self.damage_multiplier - 1) * 0.5)
			
			self.stacks = self.stacks + (
				is_critical_bone(npc:clsid(), bone_id)
				and 3 * artefact_count
				or 1 * artefact_count
			)
			self.damage_multiplier = self.damage_multiplier + (
				is_critical_bone(npc:clsid(), bone_id)
				and self.critical_hit_buff_coeff * artefact_count
				or self.hit_buff_coeff * artefact_count
			)

			change_psy_health((self.damage_multiplier - 1) * self.psy_health_restore_coeff)

			add_ui_func(
				artefact,
				true,
				artefact,
				function() return perk_based_artefacts.artefact_props.af_spaika:ui_text_func() end,
				function() return perk_based_artefacts.artefact_props.af_spaika:ui_validate_func() end
			)

			self:event_reset()
		end
	},
	af_sandstone = {
		sections = {af_sandstone = true},
		valid_hits = { -- Valid hit types to trigger
			[hit.light_burn] = true,
			[hit.burn] = true,
			[hit.shock] = true,
			[hit.chemical_burn] = true
		},
		valid_hits_table = nil, -- Table of valid hits to choose from, updates each hour
		get_seed = function(self)
			return ceil(time_elapsed * time_factor / 60 / 60)
		end,
		new_fixed_random_table = function(self)
			local a = {}
			for k, v in pairs(self.valid_hits) do
				a[#a+1] = k
			end
			return demonized_fixed_random_table.FixedRandomTable(a, self:get_seed(), 100)
		end,
		update_valid_hits_table = function(self)
			self.valid_hits_table = self.valid_hits_table or mdata_load("af_sandstone_valid_hits") or self:new_fixed_random_table()

			-- Set randomseed to current game hour and reset back later
			if self:get_seed() ~= self.valid_hits_table.seed then
				self.valid_hits_table = self:new_fixed_random_table()
			end
			mdata_save("af_sandstone_valid_hits", self.valid_hits_table)
		end,
		get_valid_hit_type = function(self)
			self:update_valid_hits_table()
			local res = self.valid_hits_table:next()
			mdata_save("af_sandstone_valid_hits", self.valid_hits_table)
			return res
		end,
		hit_types_sounds = { -- Hit type to sounds associations
			[hit.light_burn] = {
				"perk_based_artefacts\\flamer2",
			},
			[hit.burn] = {
				"perk_based_artefacts\\flamer1",
			},
			[hit.shock] = {
				"anomaly\\electra_blast",
				"anomaly\\electra_blast1"
			},
			[hit.chemical_burn] = {
				"anomaly\\bfuzz_hit",
				"anomaly\\buzz_hit"
			}
		},
		hit_types_particles = { -- Hit type to particles associations
			[hit.light_burn] = {
				"artefact\\artefact_zharka"
			},
			[hit.burn] = {
				"artefact\\artefact_zharka"
			},
			[hit.shock] = {
				"artefact\\artefact_electra"
			},
			[hit.chemical_burn] = {
				"artefact\\artefact_ameba"
			}
		},
		hit_types_icons = { -- Hit type to icons
			[hit.light_burn] = "ui_am_prop_thermo",
			[hit.burn] = "ui_am_prop_burn_immunity",
			[hit.shock] = "ui_am_prop_electro",
			[hit.chemical_burn] = "ui_am_prop_chem"
		},
		hit_power_coeff = 0.7,
		elemental_power_coeff = 0.7,
		ui_text_func = function(self)
			local actor_weapon = db.actor:active_item()
			if actor_weapon then
				return ("T:%s"):format(ceil(get_status_effect_remaining_time("af_sandstone" .. actor_weapon:name())))
			end
		end,
		ui_validate_func = function(self)
			local actor_weapon = db.actor:active_item()
			if actor_weapon then
				return check_status_effect("af_sandstone" .. actor_weapon:name())
			end
		end,
		play_particles = function(self, effect, position)
			local gibs = particles_object(get_random_array_element(self.hit_types_particles[effect.hit_type]))

			local npc_position = vector():set(position)
			npc_position.y = npc_position.y + 0.5

			if gibs and not gibs:playing() then
				gibs:play_at_pos(npc_position)
			end
		end,
		on_before_hit = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			local actor_weapon = actor:active_item()
			if not actor_weapon then
				trace("Sandstone, no active item")
				return
			end

			actor_weapon = actor_weapon:name()
			if not check_status_effect("af_sandstone" .. actor_weapon) then
				trace("Sandstone, weapon %s not infused", actor_weapon)
				return
			end

			local effect = status_effects["af_sandstone" .. actor_weapon].effect
			local elemental_hit = hit(s_hit)
			s_hit.power = s_hit.power * self.hit_power_coeff
			elemental_hit.power = elemental_hit.power * self.elemental_power_coeff
			elemental_hit.type = effect.hit_type
			elemental_hit.draftsman = npc
			npc:hit(elemental_hit)
			trace("Sandstone, effect power %s, hit_type %s", elemental_hit.power, elemental_hit.type)
			self:play_particles(effect, npc:position())
		end
	},
	af_repei = {
		sections = {af_repei = true},
		effect_time = 6,
		bleed_coeff = 0.0023, -- Bigger number => bigger bleeding damage
		hit_coeff_max = 0.4,
		hit_coeff_min = 0.1,
		on_before_hit = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			local bleeding_hit = s_hit.power * -self.bleed_coeff * artefact_count
			local k = lerp(self.hit_coeff_min, self.hit_coeff_max, npc.health)
			trace("Thistle coeff %s", k)
			s_hit.power = s_hit.power * k

			-- Make him panic
			if IsStalker(npc) then
				local panic_time = 4
				demonized_stalker_aoe_panic.npc_add_aoe_panic(npc:id(), "af_repei", panic_time, nil, nil, 2)
			end
			
			add_simple_timed_effect(self.effect_time, function()
				if not npc:alive() then return end
				npc:change_health(bleeding_hit)
				trace("Thistle, npc health %s", npc.health)
			end)
		end,
		on_hit = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, amount, local_direction, who, bone_index, last_npc_hit)
			add_simple_timed_effect(self.effect_time, function()
				if not npc:alive() then return end
				if npc.health > 0 then
					CreateTimeEvent("af_thistle_hud", "af_thistle_hud", 0, function()
						if npc.health > 0 then
							ui_enemy_health.on_hit(npc, nil, local_direction, who, bone_index)
						end
						return true
					end)
				end
			end, nil, "af_thistle_hud")
		end
	},
	af_cocoon = {
		sections = {af_cocoon = true},
		valid_hits = { -- Valid hit types to trigger
			[hit.wound] = true,
			[hit.strike] = true
		},
		protection_stacks = 0,
		protection_bonus = (function()
			local t = {}
			for stacks = 0, 10 do
				t[stacks] = 1 - round(-0.6 * stacks ^ 2 + 12 * stacks + 25) * 0.01 -- 25 -> 85% parabolic curve
			end
			return t
		end)(),
		speed_penalty_name = "af_cocoon_speed_penalty",
		speed_penalty = (function()
			local t = {}
			for stacks = 1, 10 do
				t[stacks] = 1 - stacks * 0.1
			end
			return t
		end)(),
		stack_reset = function(self)
			trace("Cocoon: stack reset")
			self.protection_stacks = 0
			remove_speed(self.speed_penalty_name)
			play_sound_on_actor("perk_based_artefacts\\cocoon_free", 1, random_float(0.92, 1))
		end,
		on_before_hit = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
			trace("Cocoon, stacks %s, reduction %s", self.protection_stacks, self.protection_bonus[self.protection_stacks])
			s_hit.power = s_hit.power * self.protection_bonus[self.protection_stacks]
			play_sound_on_actor("perk_based_artefacts\\cocoon" .. random(4), 1, random_float(0.92, 1))

			if self.protection_stacks < 10 then
				self.protection_stacks = min(self.protection_stacks + 1 * artefact_count, 10)
			end

			add_speed(self.speed_penalty_name, self.speed_penalty[self.protection_stacks], false, true)
			add_speed(self.speed_penalty_name, self.speed_penalty[self.protection_stacks], true, true)

			add_ui_func(
				artefact,
				false,
				artefact,
				function() return perk_based_artefacts.artefact_props.af_cocoon:ui_text_func() end,
				function() return perk_based_artefacts.artefact_props.af_cocoon:ui_validate_func() end
			)

			self.effect_time_trigger = time_elapsed + 10
			add_simple_timed_effect(10, nil, function()
				self:stack_reset()
			end, "af_cocoon_speed_penalty")
		end,
		effect_time_trigger = 0,
		ui_text_func = function(self)
			return ("E:%s\\nT:%s"):format(self.protection_stacks, ceil(self.effect_time_trigger - time_elapsed))
		end,
		ui_validate_func = function(self)
			return self.protection_stacks > 0
		end
	},
	-- Moss, Perk: Culinary Hyperversity
	af_moh = { -- Mutant parts bonuses
		sections = {af_moh = true},
		af_moh_snork_thirst_increase = { -- Mock item to send to actor_status_thirst to increase thirst
			sec = "af_moh_snork_thirst_increase",
			section = function(self)
				return self.sec
			end
		},
		af_moh_snork_thirst_decrease = { -- Mock item to send to actor_status_thirst to decrease thirst
			sec = "af_moh_snork_thirst_decrease",
			section = function(self)
				return self.sec
			end
		},
		effect_time = 90,
		add_speed = function(self, amount, is_sprint)
			add_speed("af_moh", 1 + amount, is_sprint, true)
		end,
		remove_speed = function(self)
			trace("af_moh remove speed")
			remove_speed("af_moh")
		end,
		add_effect = function(self, func, on_end)
			add_simple_timed_effect(self.effect_time, func, on_end, "af_moh_effect")
		end,
		remove_effect = function(self)
			trace("af_moh remove effect")
			remove_timed_effect("af_moh_effect", true)
		end,
		register = function(self, callback, func)
			register_callback(callback, func, nil, "af_moh")
		end,
		unregister = function(self)
			trace("af_moh unregister callback")
			unregister_callback("af_moh")
		end,
		reset = function(self)
			trace("af_moh reset")
			self:remove_effect()
			self:remove_speed()
			self:unregister()
		end,
		mutant_part_flesh_meat = function(self, actor)
			local valid_hits = { -- Valid hit types to trigger
				[hit.fire_wound] = true
			}

			local health_boost = 0.003
			self:add_effect(function()
				actor:change_health(health_boost)
			end)

			self:register("actor_on_before_hit", function(s_hit, bone_id, flags)
				if valid_hits[s_hit.type] then
					s_hit.power = s_hit.power * 1.33
				end
			end)
		end,
		mutant_part_boar_chop = function(self, actor)
			local valid_hits = { -- Valid hit types to trigger
				[hit.strike] = true,
				[hit.wound] = true,
				[hit.fire_wound] = true
			}
			
			self:register("actor_on_before_hit", function(s_hit, bone_id, flags)
				if valid_hits[s_hit.type] then
					s_hit.power = s_hit.power * 0.5
				end
			end)
		end,
		mutant_part_dog_meat = function(self, actor)
			local bleeding_cure_boost = 0.003
			self:add_effect(function()
				actor.bleeding = bleeding_cure_boost
				change_psy_health(0.001)
			end)
		end,
		mutant_part_psevdodog_meat = function(self, actor)
			local valid_hits = { -- Valid hit types to trigger
				[hit.telepatic] = true
			}

			self:add_effect(function()
				change_psy_health(0.003)
			end)

			self:register("actor_on_before_hit", function(s_hit, bone_id, flags)
				if valid_hits[s_hit.type] then
					trace("pseudodog hit %s", hit.telepatic)
					s_hit.power = s_hit.power * 0.5
				end
			end)
		end,
		mutant_part_krovosos_meat = function(self, actor)

			local function ignore_enemy(obj, enemy, flags) -- Remove evaluation
				if (enemy:id() == AC_ID) then
					flags.override = true
					flags.result = false
					return
				end
			end

			local function enable_enemy()
				UnregisterScriptCallback("on_enemy_eval", ignore_enemy)
				remove_status_effect("af_moh_invisibility")
			end

			local function enable_enemy_on_hit(obj, s_hit)
				if s_hit.draftsman:id() == AC_ID then
					enable_enemy()
				end
			end

			self:register("on_enemy_eval", ignore_enemy)
			RegisterScriptCallback("actor_on_weapon_fired", enable_enemy)
			RegisterScriptCallback("monster_on_before_hit", enable_enemy_on_hit)
			RegisterScriptCallback("npc_on_before_hit", enable_enemy_on_hit)
			add_status_effect(60, nil, "af_moh_invisibility")

			local bleeding_cure_boost = 0.006
			self:add_effect(function()
				actor.bleeding = bleeding_cure_boost
			end, function()
				UnregisterScriptCallback("actor_on_weapon_fired", enable_enemy)
				UnregisterScriptCallback("monster_on_before_hit", enable_enemy_on_hit)
				UnregisterScriptCallback("npc_on_before_hit", enable_enemy_on_hit)
				remove_status_effect("af_moh_invisibility")
			end)
		end,
		mutant_part_psysucker_meat = function(self, actor)

			local function ignore_enemy(obj, enemy, flags) -- Remove evaluation
				if (enemy:id() == AC_ID) then
					flags.override = true
					flags.result = false
					return
				end
			end

			local function enable_enemy()
				UnregisterScriptCallback("on_enemy_eval", ignore_enemy)
				remove_status_effect("af_moh_invisibility")
			end

			local function enable_enemy_on_hit(obj, s_hit)
				if s_hit.draftsman:id() == AC_ID then
					enable_enemy()
				end
			end

			self:register("on_enemy_eval", ignore_enemy)
			RegisterScriptCallback("actor_on_weapon_fired", enable_enemy)
			RegisterScriptCallback("monster_on_before_hit", enable_enemy_on_hit)
			RegisterScriptCallback("npc_on_before_hit", enable_enemy_on_hit)
			add_status_effect(60, nil, "af_moh_invisibility")

			self:add_effect(function()
				change_psy_health(0.008)
			end, function()
				UnregisterScriptCallback("actor_on_weapon_fired", enable_enemy)
				UnregisterScriptCallback("monster_on_before_hit", enable_enemy_on_hit)
				UnregisterScriptCallback("npc_on_before_hit", enable_enemy_on_hit)
				remove_status_effect("af_moh_invisibility")
			end)
		end,
		mutant_part_snork_hand = function(self, actor)
			local valid_hits = { -- Valid hit types to trigger
				[hit.radiation] = true,
			}

			self:add_effect(function()
				actor:change_power(0.01)
				actor:change_satiety(-0.001)
				actor:change_radiation(-0.0015)
				change_thirst(self.af_moh_snork_thirst_increase)
			end)

			self:register("actor_on_before_hit", function(s_hit, bone_id, flags)
				if valid_hits[s_hit.type] then
					trace("snork meat active")
					s_hit.power = s_hit.power * 0.5
				end
			end)
		end,
		mutant_part_chimera_meat = function(self, actor)
			local valid_hits = { -- Valid hit types to trigger
				[hit.radiation] = true,
			}

			self:add_effect(function()
				actor:change_health(0.008)
				actor:change_power(0.015)
			end)

			self:register("actor_on_before_hit", function(s_hit, bone_id, flags)
				if valid_hits[s_hit.type] then
					s_hit.power = s_hit.power * 0.66
				end
			end)

		end,
		mutant_part_lurker_meat = function(self, actor)
			local valid_hits = { -- Valid hit types to trigger
				[hit.light_burn] = true,
				[hit.burn] = true,
				[hit.shock] = true,
				[hit.chemical_burn] = true
			}

			self:register("actor_on_before_hit", function(s_hit, bone_id, flags)
				if valid_hits[s_hit.type] then
					s_hit.power = s_hit.power * 0.33
				end
			end)
		end,
		mutant_part_tushkano_meat = function(self, actor)
			self:add_speed(0.3, false)

			local valid_hits = { -- Valid hit types to trigger
				[hit.wound] = true,
				[hit.strike] = true
			}

			self:register("actor_on_before_hit", function(s_hit, bone_id, flags)
				if valid_hits[s_hit.type] then
					s_hit.power = s_hit.power * 1.2
				end
			end)
		end,
		effect_time_trigger = 0,
		ui_text_func = function(self)
			return ("T:%s"):format(ceil(self.effect_time_trigger - time_elapsed))
		end,
		ui_validate_func = function(self)
			return time_elapsed < self.effect_time_trigger
		end,
		activate_effect = function(self, actor, food_section, artefact)
			if self[food_section] then
				trace("Moss, Eating food %s", food_section)

				-- Remove 80% of satiety increase
				local satiety_increase = SYS_GetParam(2, food_section, "eat_satiety", 0)
				local satiety = actor:cast_Actor():conditions():GetSatiety()
				local required_satiety = 1 - satiety
				trace("actor satiety %s", satiety)
				actor:change_satiety(required_satiety > satiety_increase and satiety_increase * -0.8 or required_satiety * -0.8)

				self:reset()
				self[food_section](self, actor)
				add_simple_timed_effect(60, nil, function()
					self:reset()
				end, "af_moh")

				self.effect_time_trigger = time_elapsed + self.effect_time
				add_ui_func(
					artefact,
					true,
					artefact,
					function() return perk_based_artefacts.artefact_props.af_moh:ui_text_func() end,
					function() return perk_based_artefacts.artefact_props.af_moh:ui_validate_func() end,
					{
						{
							section = food_section,
						}
					}
				)
			end
		end
	},
	af_chelust = {
		sections = {af_chelust = true},
		valid_communities = { -- Valid communities to trigger
			actor_greh = true
		},
		valid_companion_communities = { -- Valid communities to trigger
			greh = true,
		},
		health_boost_valid = 0.0004,
		power_boost_valid = 0.006,
		health_boost_invalid = 0.000055,
		power_boost_invalid = 0.0005,
		heal_companion_boost = 0.002,
	},
	af_zhelch = {
		sections = {af_zhelch = true},
		health_boost = 0.003,
		psy_drain = -0.00125,
		psy_boost = 0.0035,
		psy_damage_reduction = 0.66,
		cooldown_time = 60,
		chance = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			 return 0.25 + 2.5 * (1 - get_psy_health())
		end,
		valid_hits = { -- Valid hit types to trigger
			[hit.telepatic] = true,
		},
		actions = {  -- Actions to perform

			-- Action types
			hide_weapon = function(self, actor, sound_num) -- Hide actor's weapon with sound, restore after some time
				actor:hide_weapon()
				play_sound_on_actor("perk_based_artefacts\\dropweapon_" .. sound_num or 1)

				add_simple_timed_effect(5, nil, function()
					actor:restore_weapon()
				end, "af_zhelch_restore_weapon")
			end,
			look_at_npc = function(self, actor, time) -- Look at nearest npc
				register_callback("actor_on_update", function()
					look_at_nearest_npc(nil, actor)
				end, nil, "af_zhelch_look_at_npc")

				CreateTimeEvent("af_zhelch_look_at_npc", "af_zhelch_look_at_npc", time, function()
					actor:actor_stop_look_at_point()
					unregister_callback("af_zhelch_look_at_npc")
					return true
				end)
			end,
			press_pda = function(self, actor, func, ...) -- Show pda and hide it quickly
				CloseAll_UI()
				local time = 0

				if actor:active_slot() == 8 then
					time = 0
				elseif actor:active_slot() == 0 then
					time = 0.6
				else
					time = 1.5
				end

				local delayed_time = time + 0.33
				actor:activate_slot(8)
				local t = {...}
				CreateTimeEvent("af_zhelch_press_pda", "af_zhelch_press_pda", time, function()
					actor:activate_slot(0)
					CreateTimeEvent("af_zhelch_press_pda_delay", "af_zhelch_press_pda_delay", delayed_time, function()
						func(unpack(t))
						return true
					end)
					return true
				end)
				return delayed_time
			end,
			play_muzon = function(self, actor)
				local item = actor:item_in_slot(8)
				if not item then return end

				local snd
				local function start_music()
					CreateTimeEvent("af_zhelch_muzon", "af_zhelch_muzon", 0.66, function()
						add_cam_effector("camera_effects\\tolik2.anm", 69421, true, "")
						snd = play_sound_on_actor("perk_based_artefacts\\csky_bandit")
						return true
					end)
				end

				local function end_music()
					remove_cam_effector(69421)
					if snd then snd:stop() end
				end

				local time = self:press_pda(actor, start_music)		
				CreateTimeEvent("af_zhelch_muzon_stop", "af_zhelch_muzon_stop", time + 20, function()
					self:press_pda(actor, end_music)
					return true
				end)
			end,
			fire_weapon = function(self, actor, time) -- Fire active weapon for time
				local item
				local item_slot
				local t = 0
				if actor:active_slot() == 2 or actor:active_slot() == 3 then
					item = actor:active_item()
					item_slot = actor:active_slot()
				elseif actor:item_in_slot(2) then
					item = actor:item_in_slot(2)
					item_slot = 2
					t = 1.2
				elseif actor:item_in_slot(3) then
					item = actor:item_in_slot(3)
					item_slot = 3
					t = 1.2
				else
					return t
				end

				t = t + (actor:active_slot() == 0 and 0 or 1)
				local time = time + t
				actor:activate_slot(item_slot)
				
				CreateTimeEvent("af_zhelch_activate_fire", "af_zhelch_activate_fire", t, function()
					register_callback("actor_on_update", function()
						local firekey = bind_to_dik(key_bindings.kWPN_FIRE)
						press_action(firekey)
					end, nil, "af_zhelch_fire_weapon")

					CreateTimeEvent("af_zhelch_fire_weapon", "af_zhelch_fire_weapon", time, function()
						unregister_callback("af_zhelch_fire_weapon")
						return true
					end)
					return true
				end)

				return t
			end,
			hide_all_ui = function(self, actor)  -- Hide all UI
				if actor:is_talking() then
					actor:stop_talk()
				end
				CloseAll_UI()
			end,
			hurt_psy = function(self, actor, psy_volume, psy_sounds, psy_sound_amount, hurt_psy_duration, hurt_psy_health) -- Hurt player psy health
				play_sound_on_actor("perk_based_artefacts\\psy_1", psy_volume or 0.5)

				if psy_sounds then
					local t = psy_sounds
					shuffle_table(t)
					for i = 1, (psy_sound_amount or 1) do
						CreateTimeEvent("af_zhelch_play_psy" .. i, "af_zhelch_play_psy" .. i, (i - 1) * 5.2 + 2, function()
							play_sound_on_actor("perk_based_artefacts\\psya_" .. t[i])
							return true
						end)
					end
				end

				if hurt_psy_duration and hurt_psy_health then
					add_simple_timed_effect(hurt_psy_duration, function()
						change_psy_health(-hurt_psy_health)
					end)
				end
			end,

			-- Actions list, chooses one of the below
			function(self, actor)
				self:hide_weapon(actor, random(1, 5))
			end,
			function(self, actor)
				self:hide_weapon(actor, random(1, 5))
			end,
			function(self, actor)
				for i = 0, 2 do
					CreateTimeEvent("af_zhelch_hide_weapon" .. i, "af_zhelch_hide_weapon" .. i, i * 10, function()
						self:hide_weapon(actor, i + 1)
						return true
					end)
				end
			end,
			function(self, actor)
				play_sound_on_actor("perk_based_artefacts\\f" .. random(4))
			end,
			function(self, actor)
				play_sound_on_actor("perk_based_artefacts\\dsc")
			end,
			function(self, actor)
				local function dsc()
					play_sound_on_actor("perk_based_artefacts\\dsc")
					return true
				end

				dsc()
				local x = random() * 4
				for i = 1, random(10) do
					CreateTimeEvent("af_zhelch_dsc" .. i, "af_zhelch_dsc" .. i, x, dsc)
					x = x + random() * 4
				end
			end,
			function(self, actor)
				self:play_muzon(actor)
			end,
			function(self, actor)
				self:play_muzon(actor)
			end,
			function(self, actor)
				self:play_muzon(actor)
			end,
			function(self, actor)
				self:look_at_npc(actor, 7)
			end,
			function(self, actor)
				self:hide_all_ui(actor)

				play_sound_on_actor("perk_based_artefacts\\mil_crazy" .. random(3))
				self:look_at_npc(actor, 4)
			end,
			function(self, actor)
				self:hide_all_ui(actor)
				
				local time = 1.5
				local t = self:fire_weapon(actor, time)
				CreateTimeEvent("af_zhelch_fire_weapon_sound", "af_zhelch_fire_weapon_sound", max(t - 0.5, 0), function()
					play_sound_on_actor("perk_based_artefacts\\mil_crazy" .. random(3))
					return true
				end)
			end,
			function(self, actor)
				self:hide_all_ui(actor)
				
				local time = 1.5
				local t = self:fire_weapon(actor, time)
				time = time + t
				self:look_at_npc(actor, time)
				CreateTimeEvent("af_zhelch_fire_weapon_sound", "af_zhelch_fire_weapon_sound", max(t - 0.5, 0), function()
					play_sound_on_actor("perk_based_artefacts\\mil_crazy" .. random(3))
					return true
				end)
			end,
			function(self, actor)
				self:hurt_psy(actor, 0.3, nil, nil, 5, 0.006)
			end,
			function(self, actor)
				self:hurt_psy(actor, 0.3, nil, nil, 5, 0.006)
			end,
			function(self, actor)
				self:hurt_psy(actor, 0.5, {1, 2, 3, 4, 5}, 2, 10, 0.0075)
			end,
			function(self, actor)
				self:hurt_psy(actor, 0.7, {1, 2, 3, 4, 5}, 3, 15, 0.009)
			end,
			function(self, actor)
				self:hurt_psy(actor, 0.7, {1, 2, 3, 4}, 3, 15, 0.009)

				CreateTimeEvent("af_zhelch_fatality", "af_zhelch_fatality", 16, function()
					if get_psy_health() < 0.3 then
						play_sound_on_actor("perk_based_artefacts\\psy_1", 0.8)
						play_sound_on_actor("perk_based_artefacts\\psya_fatality")
						CreateTimeEvent("af_zhelch_suicide", "af_zhelch_suicide", 5, function()
							set_psy_health(-1)
							return true
						end)
					end
					return true
				end)
			end,
			function(self, actor)
				self:hide_all_ui(actor)

				local quick_throw = actor_effects.Hit_GrenadeQuickthrow
				quick_throw()
			end,
			function(self, actor)
				self:hide_all_ui(actor)

				local quick_throw = actor_effects.Hit_GrenadeQuickthrow
				quick_throw()
			end,
			function(self, actor)
				self:hide_all_ui(actor)

				local quick_throw = actor_effects.Hit_GrenadeQuickthrow
				play_sound_on_actor("perk_based_artefacts\\mil_crazy4")

				register_callback("actor_on_update", function()
					quick_throw()
				end, nil, "af_zhelch_grenade_stop")
				
				CreateTimeEvent("af_zhelch_grenade_stop", "af_zhelch_grenade_stop", 5, function()
					unregister_callback("af_zhelch_grenade_stop")
					return true
				end)
			end,
		},
		perform_action = function(self, actor)
			local actions = self.actions
			actions[random(#actions)](actions, actor)
		end
	},
	af_bat = {
		sections = {af_bat = true},
		allow_artefacts = (function()
			local t = {}
			ini_sys:section_for_each(function(sec)
				if SYS_GetParam(0, sec, "kind", "") == "i_arty" then -- Allow artefacts
					t[sec] = true
				elseif SYS_GetParam(0, sec, "kind", "") == "i_arty_junk" then -- Allow perk artefacts
					t[sec] = true
				end
			end)
			return t
		end)(),
		ignore_artefacts = (function()
			local t = {}
			t["af_bat"] = true -- Can't mutate itself
			t["af_lucifer"] = true -- Can't mutate Lucifer

			-- Can't mutate unique artefacts
			t["af_ameba_mica"] = true
			t["af_ameba_slime"] = true
			t["af_ameba_slug"] = true
			t["af_base_mlr"] = true
			t["af_black"] = true
			t["af_compass"] = true
			t["af_control"] = true
			t["af_death_lamp"] = true
			t["af_dummy_pellicle"] = true
			t["af_dummy_spring"] = true
			t["af_geliy"] = true
			t["af_gimlet"] = true
			t["af_misery_bread"] = true
			t["af_monolith"] = true
			t["af_oasis_heart"] = true
			t["af_quest_b14_twisted"] = true
			t["af_rusty_kristall"] = true
			t["af_rusty_sea"] = true
			t["af_rusty_thorn"] = true
			t["af_vaselisk"] = true
			t["monolith_shard"] = true
			t["jup_b1_half_artifact"] = true
			t["marker"] = true

			-- Multiplayer items
			t["mp_af_electra_flash"] = true
			t["mp_zone_witches_galantine"] = true
			t["mp_af_cta_green"] = true
			t["mp_af_cta_blue"] = true
			t["mp_medkit"] = true
			t["mp_medkit_scientic"] = true
			t["mp_medkit_army"] = true
			t["mp_energy_drink"] = true
			t["mp_bandage"] = true
			t["mp_antirad"] = true
			t["mp_drug_coagulant"] = true
			t["mp_drug_radioprotector"] = true
			t["mp_medkit_old"] = true
			t["mp_antirad_old"] = true
			t["mp_detector_advanced"] = true
			t["mp_device_torch"] = true
			t["mp_players_rukzak"] = true
			t["mp_wood_stolb_fixed"] = true
			t["mp_wood_stolb_fixed_immunities"] = true
			t["mp_explosive_fuelcan"] = true
			t["mp_explosive_tank"] = true
			t["mp_explosive_barrel"] = true


			ini_sys:section_for_each(function(sec)
				if SYS_GetParam(0, sec, "kind", "") == "i_arty_cont" then -- Exclude artefacts in containers
					t[sec] = true
				elseif SYS_GetParam(0, sec, "kind", "") == "i_attach" then -- Exclude attachments
					t[sec] = true
				elseif SYS_GetParam(0, sec, "kind", "") == "i_quest" then -- Exclude quest items
					t[sec] = true
				elseif SYS_GetParam(0, sec, "kind", "") == "i_mutant_belt" then -- Exclude mutant hides
					t[sec] = true
				elseif SYS_GetParam(1, sec, "quest_item", false) then -- Exclude quest items
					t[sec] = true
				end
			end)
			return t
		end)(),
		tier_artefacts = (function()
			local t = {}
			ini_sys:section_for_each(function(sec)
				if SYS_GetParam(0, sec, "kind", "") == "i_arty" then -- If item is artefact, get its tier
					local tier = SYS_GetParam(2, sec, "tier", 1)
					if not t[tier] then t[tier] = {} end 
					t[tier][sec] = true
				end
			end)
			return t
		end)(),
		upgrade_artefacts =(function()
			local t = {
				artefact_tiers = { -- Tiers by resistance
					burn = {
						"af_itcher",
						"af_pin",
						"af_cristall",
						"af_fireball",
					},
					chem = {
						"af_blood",
						"af_mincer_meat",
						"af_bracelet",
						"af_baloon",
					},
					shock = {
						"af_electra_sparkler",
						"af_sponge",
						"af_ring",
						"af_electra_flash",
					},
					telepatic = {
						"af_cristall_flower",
						"af_lobster_eyes",
						"af_electra_moonlight",
						"af_black_spray",
					},
					physical = {
						"af_medusa",
						"af_vyvert",
						"af_empty",
						"af_full_empty",
					},
					weight = {
						"af_night_star",
						"af_gravi",
						"af_gold_fish",
					},
					bleeding = {
						"af_dummy_glassbeads",
						"af_eye",
						"af_fire",
					},
					stamina = {
						"af_dummy_battery",
						"af_dummy_dummy",
						"af_ice",
					},
					health = {
						"af_soul",
						"af_fuzz_kolobok",
						"af_glass",
					}
				},
			}

			t.artefact_to_tier = (function()
				local x = {}
				for k, v in pairs(t.artefact_tiers) do 
					for _, art in ipairs(v) do
						x[art] = k
					end
				end
				return x
			end)()

			return t
		end)(),
		perk_artefacts = (function()
			local t = {}
			ini_sys:section_for_each(function(sec)
				if SYS_GetParam(0, sec, "kind", "") == "i_arty_junk" then -- Perk artefacts have this kind
					t[sec] = true
				end
			end)
			return t
		end)(),
		check_bat = function(self)
			for k, v in pairs(self.sections) do
				local obj = db.actor:object(k)
				if obj then
					return obj
				end
			end
			return false
		end,
		get_random_artefact = function(self, sec, arts_table)
			local arts_table = arts_table or self.tier_artefacts[2]
			local new_sec = get_random_key(arts_table)
			local i = 1
			while new_sec == sec or self.ignore_artefacts[new_sec] do
				if i > 100 then
					trace("Bat, too many tries to find random artefact, returning same section %s", sec)
					new_sec = sec
					break
				end
				new_sec = get_random_key(arts_table)
				i = i + 1
			end

			return new_sec
		end,
		get_upgrade_artefact = function(self, sec)
			local tier = SYS_GetParam(2, sec, "tier", 1)
			local art = self.upgrade_artefacts
			local art_table = art.artefact_tiers[art.artefact_to_tier[sec]]
			if not art_table then
				trace("Bat, upgrade artefact table not found for %s", sec)
				return self:get_random_artefact(sec, self.tier_artefacts[tier])
			end

			local new_sec
			for i, v in ipairs(art_table) do
				if v == sec then
					new_sec = art_table[i + 1]
					break
				end
			end

			if not new_sec then
				trace("Bat, upgrade artefact not found for %s", sec)
				return self:get_random_artefact(sec, self.tier_artefacts[tier])
			end

			return new_sec
		end,
		transmutate = function(self, obj, new_artefact)
			local actor = db.actor
			local af_bat = self:check_bat()
			play_sound_on_actor("perk_based_artefacts\\transmute")
			CloseAll_UI()
			add_pp_effector("teleport.ppe", c_id_ppe.transmutate, false)
			
			alife_release_id(obj:id())
			alife_release_id(af_bat:id())
			alife_create_item(new_artefact, actor)
			CreateTimeEvent("refresh_artefacts", "refresh_artefacts", 0.15, refresh_artefacts_time_event_func, true)
		end,
		randomseed = nil,
		randomseed_update_time = nil,
		transmutate_artefact = function(self, obj)
			-- Set randomseed to current game hour and reset back
			self.randomseed = self.randomseed or mdata_load("af_bat_randomseed")
			self.randomseed_update_time = self.randomseed_update_time or mdata_load("af_bat_randomseed_update_time")

			local seed = ceil(time_elapsed * time_factor / 60 / 60)
			if self.randomseed_update_time ~= seed then
				self.randomseed = seed
				self.randomseed_update_time = seed
			else
				math.randomseed(self.randomseed)
				self.randomseed = self.randomseed + math.random(100, 200) + math.random()
			end
			math.randomseed(self.randomseed)

			mdata_save("af_bat_randomseed", self.randomseed)
			mdata_save("af_bat_randomseed_update_time", self.randomseed_update_time)

			local sec = obj:section()
			local new_sec
			if self.perk_artefacts[sec] then
				trace("Bat, transforming perk artefact %s", sec)
				new_sec = self:get_random_artefact(sec, self.perk_artefacts)
			else
				local tier = SYS_GetParam(2, sec, "tier", 1)
				if random(100) <= 35 then
					trace("Bat, transforming artefact %s to different kind", sec)
					new_sec = self:get_random_artefact(sec, self.tier_artefacts[tier])
				else
					trace("Bat, upgrading artefact %s", sec)
					new_sec = self:get_upgrade_artefact(sec)
				end
			end
			trace("Bat, resulting artefact %s", new_sec)
			self:transmutate(obj, new_sec)
			math.randomseed(os.time())
		end
	},
	af_grapes = {
		sections = {af_grapes = true},
		health_boost = 0.01,
		health_boost_time = 5,
		status_effect_key = "af_grapes_effect",
		ui_text_func = function(self)
			return ("T:%s"):format(ceil(get_status_effect_remaining_time(self.status_effect_key)))
		end,
		ui_validate_func = function(self)
			return check_status_effect(self.status_effect_key)
		end,
	},
	af_lucifer = {
		sections = {af_lucifer = true},
		health_boost = 0.001,
		psy_boost = 0.003,
		power_boost = 0.01,
		bleeding_cure_boost = 0.0025,
		speed_boost = 0,
		weight_boost = 50,
		weight_overcharge_boost = 30,
		damage_resist = 0.5,
		allow_artefacts = (function()
			local t = {}
			ini_sys:section_for_each(function(sec)
				if SYS_GetParam(0, sec, "kind", "") == "i_arty" then -- Allow artefacts
					t[sec] = true
				elseif SYS_GetParam(0, sec, "kind", "") == "i_arty_junk" then -- Allow perk artefacts
					t[sec] = true
				end
			end)
			return t
		end)(),
		ignore_tiers = (function()  -- Artefacts ignore list
			local t = {}
			t["af_serofim"] = true -- Seraphim
			t["af_lucifer"] = true -- Can't sacrifice itself
			t["monolith_shard"] = true -- Monolith Shard
			ini_sys:section_for_each(function(sec)
				if SYS_GetParam(0, sec, "kind", "") == "i_arty_cont" then -- Exclude artefacts in containers
					t[sec] = true
				elseif SYS_GetParam(0, sec, "kind", "") == "i_attach" then -- Exclude attachments
					t[sec] = true
				elseif SYS_GetParam(0, sec, "kind", "") == "i_quest" then -- Exclude quest items
					t[sec] = true
				elseif SYS_GetParam(0, sec, "kind", "") == "i_mutant_belt" then -- Exclude mutant hides
					t[sec] = true
				elseif SYS_GetParam(1, sec, "quest_item", false) then -- Exclude quest items
					t[sec] = true
				end
			end)
			return t
		end)(),
		sacrifice_tiers = { -- Tier to condition restore associations
			[1] = {
				min = 3,
				max = 5,
				sound = {
					"perk_based_artefacts\\item-soul-take",
					"perk_based_artefacts\\item-soul-take1",
					"perk_based_artefacts\\item-soul-take2",
					"perk_based_artefacts\\item-soul-take3",
					"perk_based_artefacts\\item-soul-take4",
				}
			},
			[2] = {
				min = 6,
				max = 9,
				sound = {
					"perk_based_artefacts\\item-soul-red",
				}
			},
			[3] = {
				min = 10,
				max = 13,
				sound = {
					"perk_based_artefacts\\item-soul-gold",
				}
			},
			["af_fire_loop"] = {
				min = 20,
				max = 30,
				sound = {
					"perk_based_artefacts\\take-megahealth",
				}
			},
			["af_death_lamp"] = {
				min = 100,
				max = 100,
				sound = {
					"perk_based_artefacts\\item-wm-take-mono",
					"perk_based_artefacts\\item-wm-take",
				}
			}
		},
		condition = 1,
		degradation_rate = 0.0000038, --25% per day is 0.0000029
		get_degradation_rate = function(self)
			return self.degradation_rate * time_factor
		end,
		check_lucifer = function(self)
			-- return has_alife_info("lucifer_active") and db.actor:object("af_lucifer")
			return artefacts.af_lucifer
		end,
		remove_lucifer = function(self)
			if self:check_lucifer() then
				local id = id or artefacts.af_lucifer.ids[1]
				local obj = get_object_by_id(id)
				if obj then
					alife_release_id(id)
				end
				artefacts.af_lucifer = nil
				CreateTimeEvent("refresh_artefacts", "refresh_artefacts", 0.15, function()
					refresh_artefacts_time_event_func(true)
					self.condition = 1
					return true
				end)
				disable_info("lucifer_active")
			end
		end,
		set_condition = function(self, amount, id)
			if not self:check_lucifer() then return end

			local id = id or artefacts.af_lucifer.ids[1]
			if not id then return end

			trace("lucifer id %s", id)
			trace("condition %s", self.condition)

			local af_lucifer = get_object_by_id(id)
			self.condition = amount < 1 and amount or 1
			af_lucifer:set_condition(self.condition)

			trace("new condition %s", af_lucifer:condition())
			return self.condition
		end,
		change_condition = function(self, amount, id)
			return self:set_condition(self.condition + amount, id)
		end,
		ui_text_func = function(self)
			return ("E:%s\\nT:%s"):format(
				ceil(self:get_overcharge() * 100),
				ceil(get_status_effect_remaining_time("af_lucifer_overcharge"))
			)
		end,
		ui_validate_func = function(self)
			return self:check_overcharge()
		end,
		add_overcharge = function(self)
			add_status_effect(1800, "af_lucifer_overcharge", "af_lucifer_overcharge")
			add_ui_func(
				"af_lucifer_overcharge",
				true,
				"af_lucifer",
				function() return perk_based_artefacts.artefact_props.af_lucifer:ui_text_func() end,
				function() return perk_based_artefacts.artefact_props.af_lucifer:ui_validate_func() end,
				{
					{
						section = "af_death_lamp",
					}
				}
			)
		end,
		check_overcharge = function(self)
			return check_status_effect("af_lucifer_overcharge")
		end,
		get_overcharge = function(self)
			return get_status_effect_remaining_time("af_lucifer_overcharge", true)
		end,
		sacrifice_artefact = function(self, obj, id)
			local section = obj:section()
			if self.ignore_tiers[section] then return end
			local tier_level = SYS_GetParam(2, section, "tier", 0)
			if tier_level > 1 then
				tier_level = tier_level - 1 -- Lower tier level by 1 of all tier 2+ artefacts
			end
			local tier = self.sacrifice_tiers[section] or self.sacrifice_tiers[clamp(tier_level, 0, 3)]
			if tier then
				alife_release_id(obj:id())
				CreateTimeEvent("refresh_artefacts", "refresh_artefacts", 0.15, refresh_artefacts_time_event_func, true)
				CreateTimeEvent("af_lucifer_UpdateWeight", "af_lucifer_UpdateWeight", 0.15, function()
					ui_inventory.GUI:UpdateWeight()
					return true
				end)
				local snd = play_sound_on_actor(get_random_array_element(tier.sound), 1, random_float(0.93, 1))
				if section == "af_death_lamp" then
					self:add_overcharge()

					if random(100) < 20 then

						local function die()
							local s_hit = _G.hit()
							s_hit.power = 10000
							s_hit.type = hit.explosion
							s_hit.impulse = 10000
							s_hit.direction = _G.VEC_Y
							s_hit.draftsman = db.actor

							bind_stalker_ext.invulnerable_time = _G.time_global() - 500  -- Prevent cheating death on save/load

							local function explode(explode_id)
								local explode_obj = _G.get_object_by_id(explode_id)
								if explode_obj then
									explode_obj:explode(0)
									if snd then snd:stop() end
									return true
								end
								return false
							end

							_G.printf("p %s, t %s, i %s, d %s, dm %s", s_hit.power, s_hit.type, s_hit.impulse, s_hit.direction, s_hit.draftsman)
							db.actor:hit(s_hit)

							local explode_obj = _G.alife_create_item("ied_new_blow", {db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), nil})
							_G.CreateTimeEvent(explode_obj.id, explode_obj.id, 0, explode, explode_obj.id)
						end

						add_timed_effect(1.8, nil, nil, die, nil, "af_death_lamp_die")
					end
				end
				return self:change_condition(random(tier.min, tier.max) * 0.01, id)
			end
		end
	}
}

-- Alias for Lucifer Check
function check_lucifer()
	return artefact_props.af_lucifer:check_lucifer()
end

function remove_lucifer()
	return artefact_props.af_lucifer:remove_lucifer()
end

-- PERKS SECTION
-- Functions for artefacts which provide perk bonuses continuously
artefact_on_update_functions = {

	-- Sun, Perk: Solar Powered
	af_sun = {
		get_sections = function(self, artefact) return artefact_props.af_sun.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local hours = get_time_hours()
			local af_sun = artefact_props.af_sun

			local health_boost = af_sun.health_boost
			local power_clear_boost = af_sun.power_clear_boost
			local power_partly_boost = af_sun.power_partly_boost
			local power_not_clear_penalty = af_sun.power_not_clear_penalty

			if hours >= 21 or hours <= 5 or indoor_levels[actor_level] then
				actor:change_power(power_not_clear_penalty * artefact_count)
				trace("Dark time penalty, time %s, level %s, health %s, power %s", hours, actor_level, actor.health, actor.power)
				af_sun:ui_func("--", artefact)
			else
				local current_weather = get_current_weather()
				if not current_weather then
					trace("Sun: Weather not defined")
					return
				end

				if current_weather == "clear" then
					actor:change_health(health_boost * artefact_count)
					actor:change_power(power_clear_boost * artefact_count)
					trace("Clear boost, time %s, current_weather %s, health %s, power %s", hours, current_weather, actor.health, actor.power)
					af_sun:ui_func("++", artefact)
				elseif current_weather == "partly" then
					actor:change_power(power_partly_boost * artefact_count)
					trace("Partly boost, time %s, current_weather %s, health %s, power %s", hours, current_weather, actor.health, actor.power)
					af_sun:ui_func("+", artefact)
				else
					actor:change_power(power_not_clear_penalty * artefact_count)
					trace("Not clear penalty, time %s, current_weather %s, health %s, power %s", hours, current_weather, actor.health, actor.power)
					af_sun:ui_func("-", artefact)
				end
			end
		end,
	},

	-- Tapeworm, Perk: Stunner
	af_tapeworm = {
		get_sections = function(self, artefact) return artefact_props.af_tapeworm.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local af_tapeworm = artefact_props.af_tapeworm
			if not check_cooldown("af_tapeworm") then
				trace("Tapeworm not triggered, cooldown active")
				return
			end

			iterate_nearest(actor:position(), af_tapeworm.iterate_func_radius, function(obj)
				return af_tapeworm:iterate_func(actor, artefact, artefact_count, artefact_ids, artefact_names, obj)
			end)
		end,
	},

	-- Heart, Perk: Will to Live
	af_ear = {
		get_sections = function(self, artefact) return artefact_props.af_ear.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local af_ear = artefact_props.af_ear
			local health_threshold = af_ear.health_threshold[min(5, artefact_count)]
			local health_boost = af_ear.health_boost

			local actor_health = round_100(actor.health)
			local af_lucifer = artefact_props.af_lucifer

			local k = 1 - math.min(1, normalize(actor_health, 0, health_threshold))
			af_ear.sound.volume = k
			af_ear.sound.frequency = 1 + 0.5 * k

			if actor_health < health_threshold then
				local health = (health_threshold - actor_health) * health_boost * artefact_count * (af_lucifer:check_lucifer() and min(normalize(af_lucifer.condition, -0.4, 0.5), 1) or 1) --66% of reduction at 0 Lucifer condition
				actor:change_health(health)
				trace("firing Will to Live, health %s", health)
			end
		end,
	},

	-- Moon, Perk: Friend of the Night
	af_peas = {
		get_sections = function(self, artefact) return artefact_props.af_peas.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local af_peas = artefact_props.af_peas
			local hours = get_time_hours()
			if hours >= 21 or hours <= 5 then
				local bleeding_cure_boost = af_peas.bleeding_cure_boost * artefact_count
				actor.bleeding = bleeding_cure_boost

				add_speed(speed_boosts.af_peas.name, 1 + speed_boosts.af_peas.boost * artefact_count, false, true)
				add_jump(jump_boosts.af_peas.name, 1 + jump_boosts.af_peas.boost * artefact_count, true)
				for i = 1, artefact_count do
					af_peas:change_sleep(false)
				end
				af_peas:ui_func("++", artefact)
			else
				remove_speed(speed_boosts.af_peas.name)
				remove_jump(jump_boosts.af_peas.name)
				for i = 1, artefact_count do
					af_peas:change_sleep(true)
				end
				af_peas:ui_func("--", artefact)
			end
		end,
	},

	-- Signet, Perk: Light of Tranquility
	af_signet = {
		get_sections = function(self, artefact) return artefact_props.af_signet.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local af_signet = artefact_props.af_signet
			local health_boost = af_signet.health_boost
			local status_effect_time_increment = af_signet:status_effect_time_increment(actor, artefact, artefact_count, artefact_ids, artefact_names)
			local status_effect_time_max = af_signet:status_effect_time_max(actor, artefact, artefact_count, artefact_ids, artefact_names)

			local nearby_camp = bind_campfire.get_nearby_campfire(5, true)
			if nearby_camp and nearby_camp:is_on() then
				for i = 1, artefact_count do
					actor:change_health(health_boost)
					arszi_psy.manage_psy_health()
					arszi_psy.manage_psy_health()
					arszi_psy.manage_psy_health()
					arszi_psy.manage_psy_health()
				end
				trace("firing Signet, health %s", actor.health)

				local status_effect_time = get_status_effect_remaining_time("af_signet")
				if status_effect_time < status_effect_time_max then
					local time = status_effect_time + status_effect_time_increment
					time = min(status_effect_time_max, time)
					add_status_effect(time, nil, "af_signet")
					add_ui_func(
						artefact,
						true,
						artefact,
						function() return perk_based_artefacts.artefact_props.af_signet:ui_text_func() end,
						function() return perk_based_artefacts.artefact_props.af_signet:ui_validate_func() end
					)
					add_timed_effect(
						time,
						function() return perk_based_artefacts.artefact_props.af_signet:timed_effect_func() end,
						nil,
						nil,
						nil,
						"af_signet"
					)
				end
			end
		end,
	},

	-- Atom, Perk: Arszi's Blessing
	af_atom = {
		get_sections = function(self, artefact) return artefact_props.af_atom.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local af_atom = artefact_props.af_atom
			local power_boost = af_atom.power_boost
			local radiation_cure = af_atom.radiation_cure

			local radiation = actor.radiation
			actor:change_power(radiation * power_boost * artefact_count)
			actor:change_radiation(radiation_cure * artefact_count)
		end,
	},

	-- Generator, Perk: Godzilla is Approaching
	af_generator = {
		get_sections = function(self, artefact) return artefact_props.af_generator.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local af_generator = artefact_props.af_generator
			local charge_boost = af_generator.charge_boost
			local charge_threshold = af_generator.charge_threshold -- Below this charge the item has no battery

			--Pda, Detector and NVG slots
			if IsMoveState("mcSprint") then
				for i = 8, 10 do
					local item = actor:item_in_slot(i)
					if item then
						local condition = item:condition()
						if condition > charge_threshold then
							item:set_condition(condition + charge_boost * artefact_count)
						end
					end
				end
			end
		end,
	},

	-- Sourpuss, Perk: What Colour Is Your Blood?
	af_kislushka = {
		get_sections = function(self, artefact) return artefact_props.af_kislushka.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local af_kislushka = artefact_props.af_kislushka
			local bleeding_cure_boost = af_kislushka.bleeding_cure_boost * artefact_count
			local satiety_drain = af_kislushka.satiety_drain * artefact_count

			if actor.bleeding > 0 then
				trace("before bleeding %s", actor.bleeding)
				actor.bleeding = bleeding_cure_boost
				actor:change_satiety(satiety_drain)
				trace("after bleeding %s", actor.bleeding)
			end
		end,
	},

	-- Сhain, Perk: The Weight Of Devotion
	af_chelust = {
		get_sections = function(self, artefact) return artefact_props.af_chelust.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local actor_community = actor:character_community()
			trace("Chain, actor community %s", actor_community)
			local af_chelust = artefact_props.af_chelust

			if af_chelust.valid_communities[actor_community] then
				local health_boost = af_chelust.health_boost_valid 
				local power_boost = af_chelust.power_boost_valid
				actor:change_health(health_boost)
				actor:change_power(power_boost)
				arszi_psy.manage_psy_health()
				arszi_psy.manage_psy_health()

				--get all companions
				local c = dup_table(axr_companions.non_task_companions)
				for id,squad in pairs(axr_companions.companion_squads) do
			        if (squad and squad.commander_id) then
			            for k in squad:squad_members() do
			            	c[k.id] = true
			            end
			        end
			    end

				--heal nearby companions
				local non_task_companions = c
				if is_empty(non_task_companions) then
					trace("Chain, no companions alive")
					return
				end

				local heal_companion
				local heal_companion_min_health = 1
				for id, v in pairs(non_task_companions) do
					local obj = get_object_by_id(id)
					if obj and obj:alive() then
						local obj_community = obj:character_community()
						if af_chelust.valid_companion_communities[obj_community] and obj.health < heal_companion_min_health then
							heal_companion_min_health = obj.health
							heal_companion = obj
							trace("found companion %s, community %s, health %s", id, obj_community, heal_companion_min_health)
						end
					end
				end

				if not heal_companion then
					trace("Chain, no companions need healing")
					return
				end

				trace("Chain, healing companion %s", heal_companion:id())
				local heal_companion_boost = af_chelust.heal_companion_boost
				heal_companion:change_health(heal_companion_boost)
			else
				local health_boost = af_chelust.health_boost_invalid
				local power_boost = af_chelust.power_boost_invalid

				actor:change_health(health_boost)
				actor:change_power(power_boost)
			end
		end,
	},

	-- Scar, Perk: That Insane Stalker from the Freedom Faction
	af_zhelch = {
		get_sections = function(self, artefact) return artefact_props.af_zhelch.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local af_zhelch = artefact_props.af_zhelch
			local af_lucifer = artefact_props.af_lucifer
			local health_boost = af_zhelch.health_boost
			local psy_drain = af_zhelch.psy_drain * (2 - af_lucifer.condition)
			local psy_boost = af_zhelch.psy_boost * af_lucifer.condition

			if actor.health < (advanced_stamina_system_ass and advanced_stamina_system_ass.blood_loss_limit - 0.03 or 0.97) then -- ASS compatibility
				actor:change_health(health_boost)
				change_psy_health(psy_drain)
			else
				change_psy_health(psy_boost)
			end

			if not check_cooldown("af_zhelch_action") then
				-- trace("Scar, action is in cooldown")
				return
			end

			local dice_roll = random() * 100
			local chance = af_zhelch:chance(actor, artefact, artefact_count, artefact_ids, artefact_names)
			if dice_roll > chance then
				trace("Scar, action not triggered, dice roll %s, chance %s", dice_roll, chance)
				return
			end

			af_zhelch:perform_action(actor)
			add_cooldown(af_zhelch.cooldown_time, "af_zhelch_action")
		end,
	},

	-- Phantom Star, Perk: Phantom Pacifist
	af_star_phantom = {
		get_sections = function(self, artefact) return artefact_props.af_star_phantom.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local af_star_phantom = artefact_props.af_star_phantom
			for k, v in pairs(artefact_ids) do
				local obj = get_object_by_id(v)
				if obj then
					obj:set_condition(obj:condition() - af_star_phantom.degradation_rate / artefact_count)
					if obj:condition() < 0.01 then
						alife_release(obj)
						CreateTimeEvent("refresh_artefacts", "refresh_artefacts", 0.15, refresh_artefacts_time_event_func, true)
					end
				end
			end
		end,
	},

	-- Sandstone
	af_sandstone = {
		get_sections = function(self, artefact) return artefact_props.af_sandstone.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local af_sandstone = artefact_props.af_sandstone
			local wpn = actor:active_item()
			if wpn and check_status_effect("af_sandstone" .. wpn:name()) then
				add_ui_func(
					artefact,
					true,
					artefact,
					function() return perk_based_artefacts.artefact_props.af_sandstone:ui_text_func() end,
					function() return perk_based_artefacts.artefact_props.af_sandstone:ui_validate_func() end,
					{
						{
							icon = status_effects["af_sandstone" .. wpn:name()].effect.hit_type_icon
						}
					}
				)
			end
		end,
	},

	-- Lucifer, Perk: The Lucifer Effect
	af_lucifer = {
		get_sections = function(self, artefact) return artefact_props.af_lucifer.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			if not artefact_ids[1] then return end

			local af_lucifer = get_object_by_id(artefact_ids[1])
			local _self = artefact_props.af_lucifer
			local condition = _self.condition

			local health_boost = _self.health_boost
			local psy_boost = _self.psy_boost
			local power_boost = _self.power_boost
			local bleeding_cure_boost = _self.bleeding_cure_boost
			local speed_boost = _self.speed_boost

			af_lucifer:set_condition(condition) -- Double set to set initial condition after loading state

			if condition > 0.5 then
				local overcharge = _self:get_overcharge()
				local normal_condition = normalize(condition, 0.5, 1)
				actor:change_health(health_boost * normal_condition + health_boost * 0.5 * overcharge)
				actor:change_power(power_boost * normal_condition + power_boost * overcharge)
				actor.bleeding = bleeding_cure_boost * normal_condition + bleeding_cure_boost * overcharge
				change_psy_health(psy_boost * normal_condition + psy_boost * overcharge)
				speed_boost = speed_boosts.af_lucifer.boost * normal_condition
				add_weight("af_lucifer_weight", _self.weight_boost * normal_condition + _self.weight_overcharge_boost * overcharge, true)
			else
				local normal_condition = normalize(condition, 0, 0.5) - 1
				actor:change_power(power_boost * normal_condition * 0.3)
				if condition < 0.35 then
					actor:change_health(health_boost * normal_condition * 0.27)
				end
				if condition < 0.0001 then
					condition = 0.03
					_self:set_condition(condition, artefact_ids[1])
					actor:set_health_ex(0)
					return
				end

				if check_cooldown("af_lucifer_action") then
					local dice_roll = random() * 100
					local chance = 0.5
					if dice_roll <= chance then
						local function blood_sky()
							local function modify_val_vec(name, add_R, add_G, add_B)
								local get_val_vec = weather.get_value_vector(name)
								local mod_R = clamp(get_val_vec.x + add_R, 0, 1)
								local mod_G = clamp(get_val_vec.y + add_G, 0, 1)
								local mod_B = clamp(get_val_vec.z + add_B, 0, 1)
								trace("sky color %s, %s, %s", mod_R, mod_G, mod_B)
								weather.set_value_vector(name, mod_R, mod_G, mod_B)
							end

							local sounds = {
								"perk_based_artefacts\\dream_sequence_example1",
							}
							play_sound_on_actor(get_random_array_element(sounds), 0.66, random_float(0.95, 1))
							change_psy_health(-random_float(0.25, 0.4))

							local get_val_vec = weather.get_value_vector("sky_color")
							local r = 0
							local g = 0
							local b = 0
							register_callback("actor_on_update", function()
								r = r - 0.0015
								g = g - 0.0015
								b = b + 0.0015
								modify_val_vec("sky_color", r, g, b)
							end, function()
								add_pp_effector("black_infinite.ppe", c_id_ppe.black_infinite, true)
								CreateTimeEvent("af_lucifer_black", "af_lucifer_black", 0.5, function()
									weather.set_value_vector("sky_color", get_val_vec.x, get_val_vec.y, get_val_vec.z)
									remove_pp_effector(c_id_ppe.black_infinite)
									return true
								end)
							end, "af_lucifer_sky_color")

							CreateTimeEvent("af_lucifer_remove", "af_lucifer_remove", 7, function()
								unregister_callback("af_lucifer_sky_color")
								return true
							end)
						end

						if condition > 0.4 then
							local sounds = {
								"perk_based_artefacts\\heartbeat_pulse_loop",
								"perk_based_artefacts\\heartbeat_pulse_loop",
								"perk_based_artefacts\\heartbeat_loop",
								"perk_based_artefacts\\heartbeat_loop",
								"perk_based_artefacts\\startlevel",
								"perk_based_artefacts\\startlevel",
								"perk_based_artefacts\\churchbell_loop",
								"perk_based_artefacts\\churchbell_loop",
								"perk_based_artefacts\\churchbell_loop",
								"perk_based_artefacts\\death_chant",
								"perk_based_artefacts\\death_chant2",
								"perk_based_artefacts\\devil_prayer",
								"perk_based_artefacts\\devil_prayer2",
								"perk_based_artefacts\\devil_prayer3",
								"perk_based_artefacts\\dream_sequence_example1",
								"perk_based_artefacts\\dream_sequence_example1",
							}
							play_sound_on_actor(get_random_array_element(sounds), max(0.25, 1 - normalize(condition, 0, 0.5)), random_float(0.95, 1))
							change_psy_health(-random_float(0.1, 0.15))
						elseif condition > 0.25 then
							if random(100) <= 25 then
								blood_sky()
							else
								local sounds = {
									"perk_based_artefacts\\heartbeat_pulse_loop",
									"perk_based_artefacts\\heartbeat_loop",
									"perk_based_artefacts\\startlevel",
									"perk_based_artefacts\\churchbell_loop",
									"perk_based_artefacts\\death_chant",
									"perk_based_artefacts\\death_chant2",
									"perk_based_artefacts\\devil_prayer",
									"perk_based_artefacts\\devil_prayer2",
									"perk_based_artefacts\\devil_prayer3",
									"perk_based_artefacts\\dream_sequence_example1",
									"perk_based_artefacts\\helpme",
									"perk_based_artefacts\\creepy_moaning",
									"perk_based_artefacts\\crying_01",
									"perk_based_artefacts\\crying_03",
									"perk_based_artefacts\\devilbaby_01",
									"perk_based_artefacts\\tortured_voices",
									"perk_based_artefacts\\ohgodplease",
									"perk_based_artefacts\\screams_01",
								}
								play_sound_on_actor(get_random_array_element(sounds), max(0.25, 1 - normalize(condition, 0, 0.5)), random_float(0.95, 1))
								change_psy_health(-random_float(0.15, 0.25))
							end
						else
							if random(100) <= 50 then
								blood_sky()
							else
								local sounds = {
									"perk_based_artefacts\\startlevel",
									"perk_based_artefacts\\churchbell_loop",
									"perk_based_artefacts\\helpme",
									"perk_based_artefacts\\creepy_moaning",
									"perk_based_artefacts\\crying_01",
									"perk_based_artefacts\\crying_03",
									"perk_based_artefacts\\devilbaby_01",
									"perk_based_artefacts\\tortured_voices",
									"perk_based_artefacts\\ohgodplease",
									"perk_based_artefacts\\screams_01",
								}
								play_sound_on_actor(get_random_array_element(sounds), max(0.25, 1 - normalize(condition, 0, 0.5)), random_float(0.95, 1))
								change_psy_health(-random_float(0.15, 0.35))
							end
						end
						add_cooldown(180, "af_lucifer_action")
					end
				else
					-- trace("Lucifer, action is in cooldown")
				end
			end

			add_speed(speed_boosts.af_lucifer.name, 1 + speed_boost, true, true)
			add_speed(speed_boosts.af_lucifer.name, 1 + speed_boost, false, true)

			local degradation_rate = _self:get_degradation_rate()
			local adjust_condition = max(0, saved_time_elapsed > 0 and time_elapsed > 0 and degradation_rate * (time_elapsed - saved_time_elapsed) or degradation_rate * 0.1)
			_self.condition = condition - adjust_condition
			af_lucifer:set_condition(_self.condition)
			if settings.debug_mode then
				trace("Lucifer, time %s, last time %s, degradation %s, cond %s, new_cond %s", time_elapsed, saved_time_elapsed, round_idp(adjust_condition, 8), round_idp(condition, 4), round_idp(_self.condition, 4))
			end
		end,
	},
}

--Functions for artefacts which provide perk bonuses after weapon fired
artefact_on_weapon_fired_functions = {

	-- Knot, Perk: Superhot Deathloop
	-- Having last bullet in the magazine amplifies your reflexes
	-- Time around you slows down when you stop and moves normally only when you move
	-- The effect is short timed, if you missed the opportunity - too bad
	-- Weapons with no mags or only one bullet in the mag are ignored
	-- Multiple artefacts increase the magnitude of effect and slightly increase the duration

	-- af_fire_loop = function(actor, artefact, artefact_count, artefact_ids, artefact_names, obj, wpn, ammo_elapsed, grenade_elapsed, ammo_type, grenade_type)
	-- 	local current_weapon = actor:active_item()
	-- 	if not current_weapon then
	-- 		trace("Knot, no current_weapon")
	-- 		return
	-- 	end

	-- 	local sec = current_weapon:section()
	-- 	local name = current_weapon:name()
	-- 	local mag_size = SYS_GetParam(2, sec, "ammo_mag_size", 0)
	-- 	if mag_size < 2 then
	-- 		trace("Knot, mag size is too small: %s", mag_size)
	-- 		return
	-- 	end

	-- 	local casted_weapon = current_weapon:cast_Weapon()
	-- 	if not casted_weapon then
	-- 		trace("Knot, no casted weapon")
	-- 		return
	-- 	end



	-- 	local ammo_elapsed = ammo_elapsed - 1
	-- 	trace(ammo_elapsed)
	-- 	remove_timed_effect(name, true)

	-- 	if ammo_elapsed == 1 and actor:alive() then
	-- 		local time = 1.5 + artefact_count
	-- 		local target_time_factor = 1 / (artefact_count + 1)
	-- 		add_timed_effect(time, function()
	-- 			get_console():execute("time_factor " .. target_time_factor)
	-- 		end, nil, function()
	-- 			get_console():execute("time_factor " .. 1)
	-- 		end, nil, name, true)
	-- 		trace("Knot, effect fired")
	-- 	else
	-- 		trace("Knot, effect not fired: elapsed %s, timed_effects %s, alive %s, available %s", ammo_elapsed, actor:alive())
	-- 	end

	-- end

	-- Spike, Perk: Critical Ascensi0n
	af_spaika = {
		get_sections = function(self, artefact) return artefact_props.af_spaika.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, obj, wpn, ammo_elapsed, grenade_elapsed, ammo_type, grenade_type)
			-- Return if bullet callbacks are available
			if _G.CBulletOnImpact and _G.CBulletOnInit then
				return
			end

			local af_spaika = artefact_props.af_spaika
			trace("Spike, on_weapon_fired weapon_shot %s", af_spaika.weapon_shot)

			if af_spaika.weapon_shot then
				af_spaika:effect_reset()
				return
			end

			af_spaika.weapon_shot = true
			CreateTimeEvent("af_spaika", "af_spaika_reset", 2, function()
				trace("Spike, Creating time event")
				af_spaika:effect_reset()
				return true
			end)
		end,
	},

	-- Sandstone, perk: Zone Infusion
	af_sandstone = {
		get_sections = function(self, artefact) return artefact_props.af_sandstone.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, obj, wpn, ammo_elapsed, grenade_elapsed, ammo_type, grenade_type)
			local actor_weapon = actor:active_item():name()
			if not check_status_effect("af_sandstone" .. actor_weapon) then
				trace("Sandstone, weapon %s not infused", actor_weapon)
				return
			end

			local hit_type = status_effects["af_sandstone" .. actor_weapon].effect.hit_type
			local af_sandstone = artefact_props.af_sandstone
			play_sound_on_actor(get_random_array_element(af_sandstone.hit_types_sounds[hit_type]), 0.5, random_float(0.95, 1.05))
		end,
	},
}

-- Functions for artefacts which provide perk bonuses on item use
artefact_on_item_use_functions = {

	-- Grapes, Perk: Necessary Gluttony
	af_grapes = {
		get_sections = function(self, artefact) return artefact_props.af_grapes.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, obj)
			if not obj then
				trace("Food object not found")
				return
			end

			local af_grapes = artefact_props.af_grapes
			local health_boost = af_grapes.health_boost
			local health_boost_time = af_grapes.health_boost_time

			local sec = obj:section()
			local satiety_increase = SYS_GetParam(2, sec, "eat_satiety", 0) * health_boost
			if satiety_increase > 0 then
				add_timed_effect(health_boost_time * artefact_count, function(satiety_increase)
					db.actor:change_health(satiety_increase)
					_G.printf("health increased by %s", satiety_increase)
				end, {satiety_increase})

				add_status_effect(health_boost_time * artefact_count, nil, af_grapes.status_effect_key)
				add_ui_func(
					af_grapes.status_effect_key,
					true,
					artefact,
					function() return perk_based_artefacts.artefact_props.af_grapes:ui_text_func() end,
					function() return perk_based_artefacts.artefact_props.af_grapes:ui_validate_func() end
				)
			end
		end,
	},

	-- Moss, Perk: Culinary Hyperversity
	af_moh = {
		get_sections = function(self, artefact) return artefact_props.af_moh.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, obj)
			if not obj then
				trace("Food object not found")
				return
			end

			artefact_props.af_moh:activate_effect(actor, obj:section(), artefact)
		end,
	},
}

function af_serofim_cheat_death()
	local actor = db.actor
	local c_id_ppe_black_infinite = 5606
	local hud_state = perk_based_artefacts.hud_state

	bind_stalker_ext.invulnerable_time = time_global()
	level.enable_input()
	level.remove_pp_effector(c_id_ppe_black_infinite)
	get_console():execute("snd_volume_eff " .. _G.amb_vol)
	get_console():execute("snd_volume_music " .. _G.mus_vol)
	_G.mus_vol = 0
	_G.amb_vol = 0
	get_console():execute("hud_draw " .. hud_state)
	CreateTimeEvent("af_serofim_cheat_death", "af_serofim_cheat_death", 0.5, function()
		xr_effects.play_snd(actor, nil, {[1] = "perk_based_artefacts\\fast_fire_dusk"})
		return true
	end)
end

-- Functions for artefacts which provide perk bonuses on before actor death
artefact_on_before_death_functions = {

	-- Seraphim, Perk: Rain of Revival
	af_serofim = {
		get_sections = function(self, artefact) return artefact_props.af_serofim.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, whoID, flags)
			if actor_is_dying == true then
				flags.ret_value = false
				return
			end

			actor_is_dying = true
			disable_input()
			bind_stalker_ext.invulnerable_time = time_global() + 10000

			if actor:is_talking() then
				actor:stop_talk()
			end

			hud_state = get_console():get_bool("hud_draw") and 1 or 0
			get_console():execute("hud_draw 0")

			local actor_weapon = actor:active_item()

			if actor_weapon then
				actor:drop_item(actor_weapon)
			end

			add_cam_effector("camera_effects\\surge_02.anm", 444, false, "perk_based_artefacts.af_serofim_cheat_death")
			add_pp_effector("actor_death.ppe", c_id_ppe.actor_death, true)
			add_pp_effector("rcom_actor_death_quick.ppe", c_id_ppe.rcom_actor_death_quick, true)

			local amb_vol_coeff = 1
			_G.mus_vol = get_console():get_float("snd_volume_music")
			_G.amb_vol = get_console():get_float("snd_volume_eff")
			add_simple_timed_effect(0.8, function()
				amb_vol_coeff = amb_vol_coeff - 0.08
				get_console():execute("snd_volume_eff " .. _G.amb_vol * amb_vol_coeff)
			end)
			get_console():execute("snd_volume_music 0")

			flags.ret_value = false

			local af_serofim = artefact_props.af_serofim
			RegisterScriptCallback("actor_on_before_hit", af_serofim.ignore_all_damage_function)
			RegisterScriptCallback("on_enemy_eval", af_serofim.ignore_enemy_on_down_function)

			local function revive()
				actor:set_health_ex(0.5)
				actor.power = 1
				actor.radiation	= 0
				actor.bleeding = 1
				actor.psy_health = 1
				set_psy_health(1)
			end

			-- Ironman patch
			local ironman = alife_storage_manager.get_state().ironman
			local new_ironman_death_count = af_serofim.ironman_death_count
			local function ironman_patch()
				if ironman and ironman.death_count then
					trace("ironman is active, death count %s, new_count %s, limit %s", ironman.death_count, new_ironman_death_count, ironman.death_limit)
					ironman.death_count = new_ironman_death_count
				end
			end

			revive()
			CreateTimeEvent("af_serofim_break_sound", "af_serofim_break_sound", 1.3, function()
				xr_effects.play_snd(actor, nil, {[1] = "material\\bottle\\collide\\bottle_break_1"})
				return true
			end)
			CreateTimeEvent("af_serofim", "af_serofim", 2, function()
				trace("unregistering callback")
				UnregisterScriptCallback("on_enemy_eval", af_serofim.ignore_enemy_on_down_function)	
				ironman_patch()

				add_simple_timed_effect(af_serofim.invulnerability_time, revive, function()
					remove_pp_effector(c_id_ppe.blur)
					remove_pp_effector(c_id_ppe.snd_shock)
					remove_pp_effector(c_id_ppe.actor_death)
					remove_pp_effector(c_id_ppe.rcom_actor_death_quick)
					UnregisterScriptCallback("actor_on_before_hit", af_serofim.ignore_all_damage_function)
					ironman_patch()
					actor_is_dying = false
				end)

				af_serofim.effect_time_trigger = time_elapsed + af_serofim.invulnerability_time
				add_ui_func(
					artefact,
					false,
					artefact,
					function() return perk_based_artefacts.artefact_props.af_serofim:ui_text_func() end,
					function() return perk_based_artefacts.artefact_props.af_serofim:ui_validate_func() end
				)

				return true
			end)
			if artefact_ids[1] then
				alife_release_id(artefact_ids[1])
				CreateTimeEvent("refresh_artefacts", "refresh_artefacts", 0.15, refresh_artefacts_time_event_func, true)
			end
		end,
	},
}

-- Functions for artefacts which provide perk bonuses on before actor hit
artefact_on_before_hit_functions = {

	-- Heart, Perk: Will to Live
	af_ear = {
		get_sections = function(self, artefact) return artefact_props.af_ear.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
			local af_ear = artefact_props.af_ear
			local health_threshold = af_ear.health_threshold[min(5, artefact_count)]
			local actor_health = round_100(actor.health)
			local k = min(normalize(actor_health, 0.15, health_threshold), 1)
			local new_k = lerp(0.6 - 0.1 * artefact_count, 1, k)
			trace("af_ear, hit power k %s", new_k)
			s_hit.power = s_hit.power * new_k
		end,
	},

	-- Black Angel, perk: Dodge This
	af_black_angel = {
		get_sections = function(self, artefact) return artefact_props.af_black_angel.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
			local af_black_angel = artefact_props.af_black_angel
			if not af_black_angel.valid_hits[s_hit.type] then
				trace("Black Angel, not a valid hit type %s", s_hit.type)
				return
			end

			af_black_angel.dice_roll = random(100)
			if af_black_angel.dice_roll <= af_black_angel.reflect_chance[min(5, artefact_count)] then
				s_hit.power = 0.001
			end
		end,
	},

	-- Medallion, Perk: The (Un)lucky charm
	-- af_medallion = function(actor, artefact, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
	-- 	local af_medallion = artefact_props.af_medallion
	-- 	if not af_medallion.valid_hits[s_hit.type] then
	-- 		trace("Medallion, not a valid hit type %s", s_hit.type)
	-- 		return
	-- 	end

	-- 	local dice_roll = random(100)
	-- 	if dice_roll > af_medallion.reflect_chance[min(5, artefact_count)] then
	-- 		trace("Medallion, perk not triggered, dice_roll %s, chance %s", dice_roll, af_medallion.reflect_chance[min(5, artefact_count)])
	-- 		return
	-- 	end

	-- 	local companion, squad, squad_member_count, squad_id, squad_member_ids = (function()
	-- 		local companion_squads = axr_companions.companion_squads
	-- 		local non_task_companions = axr_companions.non_task_companions
	-- 		if is_not_empty(non_task_companions) then
	-- 			trace("Medallion, has non_task_companions")
	-- 			return alife_object(get_random_key(non_task_companions))
	-- 		elseif is_not_empty(companion_squads) then
	-- 			trace("Medallion, has companion_squads")
	-- 			for k, squad in pairs(companion_squads) do
	-- 				if squad then
	-- 					local m
	-- 					local squad_ids = {}
	-- 					for sm in squad:squad_members() do
	-- 						if not m then
	-- 							m = sm
	-- 						end
	-- 						squad_ids[sm.id] = true
	-- 					end
	-- 					return m, squad, squad:npc_count(), k, squad_ids
	-- 				end
	-- 			end
	-- 		else
	-- 			trace("Medallion, doesn't have both companion_squads, non_task_companions")
	-- 			return nil
	-- 		end
	-- 	end)()
	-- 	if not companion then
	-- 		trace("Medallion, no companion found")
	-- 		return
	-- 	end

	-- 	trace("Medallion, current companion %s", companion.id)

	-- 	local member = get_object_by_id(companion.id)
	-- 	if member and member:alive() then
	-- 		local redirect_hit = hit(s_hit)
	-- 		redirect_hit.power = redirect_hit.power * 0.5
	-- 		member:hit(redirect_hit)
	-- 		trace("Medallion, hitting companion %s, power %s", member:name(), redirect_hit.power)
			
	-- 		if squad then
	-- 			if random(100) < (10 / squad_member_count) then
	-- 				trace("Medallion, squad %s became enemy", squad_id)
	-- 				squad:set_squad_relation("enemy")
	-- 				axr_companions.dismiss_special_squad(squad)
	-- 				for k, v in pairs(squad_member_ids) do
	-- 					local obj = get_object_by_id(k)
	-- 					if obj and obj:alive() then
	-- 						trace("Medallion, squad companion %s became enemy", k)
	-- 						obj:set_relation(game_object.enemy, actor)
	-- 						af_medallion.enemy_squad_member_ids[k] = true
	-- 					end
	-- 				end
	-- 			end
	-- 		else
	-- 			if random(100) < 10 then
	-- 				trace("Medallion, companion became enemy")
	-- 				axr_companions.remove_from_actor_squad(member)

	-- 				if member:alive() then
	-- 					trace("Medallion, member %s became enemy", member:id())
	-- 					member:set_relation(game_object.enemy, actor)
	-- 					af_medallion.enemy_squad_member_ids[member:id()] = true
	-- 				end
	-- 			end
	-- 		end
	-- 		af_medallion:register()

	-- 		s_hit.power = 0.001
	-- 	end
	-- end,

	-- Electron, Perk: Crank High Voltage
	af_elektron = {
		get_sections = function(self, artefact) return artefact_props.af_elektron.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
			local af_elektron = artefact_props.af_elektron
			if s_hit.draftsman:id() == AC_ID then
				trace("Electron, hit draftsman is actor")
				return
			end

			if not af_elektron.valid_hits[s_hit.type] then
				trace("Electron, not a valid hit type %s", s_hit.type)
				return
			end

			-- 50% reduction
			s_hit.power = s_hit.power * 0.5

			for i = 8, 10 do
				local item = actor:item_in_slot(i)
				if item then
					item:set_condition(1)
				end
			end
			actor:iterate_inventory(function(npc, item)
				local sec = item:section()
				if (IsItem("device", sec) or sec == "batteries_dead") and random(100) < 40 then
					item:set_condition(1)
				end
			end, actor)

			local time
			if random() * 100 < 2 then
				time = af_elektron.buff_time_rare
				play_sound_on_actor("perk_based_artefacts\\lyutii", 0.6)
			else
				time = af_elektron.buff_time
				play_sound_on_actor("perk_based_artefacts\\rnd_scr3", 1)
			end
			local key = "af_elektron"

			add_status_effect(time, nil, "af_elektron", 1)

			if not (timed_effects[key] and timed_effects[key].timer > (time_elapsed + time)) then
				add_timed_effect(time, af_elektron.buff_func_time_effect, nil, af_elektron.buff_func_time_effect_reset, nil, "af_elektron")
				add_ui_func(
					key,
					true,
					artefact,
					function() return perk_based_artefacts.artefact_props.af_elektron:ui_text_func() end,
					function() return perk_based_artefacts.artefact_props.af_elektron:ui_validate_func() end
				)
			end
		end,
	},

	-- Cell, Perk: Disintegrator
	af_cell = {
		get_sections = function(self, artefact) return artefact_props.af_cell.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
			local af_cell = artefact_props.af_cell
			if not af_cell.valid_hits[s_hit.type] then
				trace("Cell, not a valid hit type %s", s_hit.type)
				return
			end

			local rad_k = af_cell.reduction_coeff[min(5, artefact_count)]
			local power = s_hit.power
			s_hit.power = s_hit.power * (1 - rad_k)
			power = power - s_hit.power
			local rad_amount = power * af_cell.rad_amount_coeff
			trace("Cell: resulted radiation %s", rad_amount)
			actor:change_radiation(rad_amount)
			play_sound_on_actor("anomaly\\electra_hit" .. get_random_array_element({"", "1"}), 1, 1 - artefact_count * 0.1)

			local function rad_sound()
				play_sound_on_actor("detectors\\geiger_" .. random(8), 1)
				return true
			end

			for i = 1, min(5, artefact_count) do
				CreateTimeEvent("af_cell" .. i, "af_cell" .. i, random_float(0.15, 0.3) * i, rad_sound)
			end
		end,
	},

	-- Cocoon, perk: Stone Skin
	af_cocoon = {
		get_sections = function(self, artefact) return artefact_props.af_cocoon.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
			local af_cocoon = artefact_props.af_cocoon
			if not af_cocoon.valid_hits[s_hit.type] then
				trace("Cocoon, not a valid hit type %s", s_hit.type)
				return
			end

			af_cocoon:on_before_hit(actor, artefact, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
		end,
	},

	-- Scar, Perk: That Insane Stalker from the Freedom Faction
	af_zhelch = {
		get_sections = function(self, artefact) return artefact_props.af_zhelch.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
			local af_zhelch = artefact_props.af_zhelch
			if not af_zhelch.valid_hits[s_hit.type] then
				trace("Scar, not a valid hit type %s", s_hit.type)
				return
			end

			s_hit.power = s_hit.power * af_zhelch.psy_damage_reduction
		end,
	},
	
	-- Lucifer, Perk: The Lucifer Effect
	af_lucifer = {
		get_sections = function(self, artefact) return artefact_props.af_lucifer.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, s_hit, bone_id, flags)
			local af_lucifer = artefact_props.af_lucifer
			local overcharge = af_lucifer:get_overcharge()
			s_hit.power = s_hit.power * (1 - af_lucifer.damage_resist * clamp(normalize(af_lucifer.condition, 0.5, 1), 0, 1) - overcharge * 0.15) -- 50% reduction at 100% condition
		end,
	},
}

-- Functions for artefacts which provide perk bonuses on actor hit
artefact_on_hit_functions = {

	-- Black Angel, perk: Dodge This
	af_black_angel = {
		get_sections = function(self, artefact) return artefact_props.af_black_angel.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, obj, amount, who, last_hit)
			local af_black_angel = artefact_props.af_black_angel
			if af_black_angel.dice_roll > af_black_angel.reflect_chance[min(5, artefact_count)] then
				trace("Black Angel not triggered, dice roll %s, chance %s", af_black_angel.dice_roll, af_black_angel.reflect_chance[min(5, artefact_count)])
				return
			end
			if not (
				last_hit and
				af_black_angel.valid_hits[last_hit.type] and
				who and
				obj
			) then
				trace("Black Angel not triggered, not valid hit")
				return
			end

			local s_hit = hit(last_hit)
			s_hit.power = s_hit.power * 0.35
			s_hit.draftsman = who

			who:hit(s_hit)
			trace("hit %s, last_hit %s", s_hit.power, last_hit.power)
		end,
	},

	-- Tapeworm, Perk: Stunner
	af_tapeworm = {
		get_sections = function(self, artefact) return artefact_props.af_tapeworm.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, obj, amount, who, last_hit)
			local af_tapeworm = artefact_props.af_tapeworm
			if not check_cooldown("af_tapeworm") then
				trace("Tapeworm not triggered, cooldown active")
				return
			end

			if not (
				last_hit and
				af_tapeworm.valid_hits[last_hit.type] and
				who and
				not IsAnomaly(who) and
				obj
			) then
				trace("Tapeworm not triggered, not valid hit")
				return
			end

			af_tapeworm:stun_func(actor, artefact, artefact_count, artefact_ids, artefact_names, obj, amount, who, last_hit)
		end,
	},

	-- Sandstone, perk: Zone Infusion
	af_sandstone = {
		get_sections = function(self, artefact) return artefact_props.af_sandstone.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, obj, amount, who, last_hit)
			local af_sandstone = artefact_props.af_sandstone
			if not (last_hit and af_sandstone.valid_hits[last_hit.type]) then
				trace("Sandstone, not valid hit type")
				return
			end

			if not (who and IsAnomaly(who)) then
				trace("Sandstone, not Anomaly %s", who:section())
				return
			end

			local actor_weapon = actor:active_item()
			if not actor_weapon then
				trace("Sandstone, no active actor_weapon")
				return
			end

			add_status_effect(180, {
				weapon_name = actor_weapon:name(),
				hit_type = last_hit.type,
				hit_type_icon = af_sandstone.hit_types_icons[last_hit.type],
			}, "af_sandstone" .. actor_weapon:name(), true)
		end,
	},
}

-- Functions for artefacts which provide perk bonuses on before npc hit
artefact_on_npc_before_hit_functions = {

	-- Claw, Perk: Bloodlust
	af_kogot = {
		get_sections = function(self, artefact) return artefact_props.af_kogot.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			artefact_props.af_kogot:on_before_hit(actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
		end,
	},

	-- Dragon's Eye, Perk: Good ol' Ultra-Violence
	af_dragon_eye = {
		get_sections = function(self, artefact) return artefact_props.af_dragon_eye.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			artefact_props.af_dragon_eye:on_before_hit(actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
		end,
	},

	-- Spike, Perk: Critical Ascensi0n
	af_spaika = {
		get_sections = function(self, artefact) return artefact_props.af_spaika.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			artefact_props.af_spaika:on_before_hit(actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
		end,
	},

	-- Sandstone, perk: Zone Infusion
	af_sandstone = {
		get_sections = function(self, artefact) return artefact_props.af_sandstone.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			artefact_props.af_sandstone:on_before_hit(actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
		end,
	},

	-- Thistle, perk: Minor Laceration
	af_repei = {
		get_sections = function(self, artefact) return artefact_props.af_repei.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			artefact_props.af_repei:on_before_hit(actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
		end,
	},

	-- Sun, Perk: Solar Powered
	af_sun = {
		get_sections = function(self, artefact) return artefact_props.af_sun.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			artefact_props.af_sun:on_before_hit(actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
		end,
	},
}

-- Functions for artefacts which provide perk bonuses on npc hit
artefact_on_npc_hit_functions = {

	-- Thistle, perk: Minor Laceration
	af_repei = {
		get_sections = function(self, artefact) return artefact_props.af_repei.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, amount, local_direction, who, bone_index, last_npc_hit)
			artefact_props.af_repei:on_hit(actor, artefact, artefact_count, artefact_ids, artefact_names, npc, amount, local_direction, who, bone_index, last_npc_hit)
		end,
	},
}

-- Functions for artefacts which provide perk bonuses on npc death
artefact_on_npc_death_functions = {

	-- Miser's Skull, Perk: Crack the jackpot
	af_skull_miser = {
		get_sections = function(self, artefact) return artefact_props.af_skull_miser.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, who, last_npc_hit, last_npc_hit_bone_index)
			local af_skull_miser = artefact_props.af_skull_miser
			if not (last_npc_hit and last_npc_hit_bone_index and af_skull_miser.head_bones[last_npc_hit_bone_index]) then
				trace("Miser's Skull not triggered, bone index %s", last_npc_hit_bone_index)
				return
			end

			local npc_level_vertex_id = npc:level_vertex_id()
			local npc_game_vertex_id = npc:game_vertex_id()

			local money_items = af_skull_miser.money_items
			local money_fountain_minimal_force = 125
			local money_fountain_force = 200

			local function money_fountain(money_item_id)
				local money = get_object_by_id(money_item_id)
				if money then
					trace("money spawned")
					local random_force = random()
					money:get_physics_shell():apply_force(
						money_fountain_minimal_force + random_force * money_fountain_force,
						(money_fountain_minimal_force + random_force * money_fountain_force) * 5,
						money_fountain_minimal_force + random_force * money_fountain_force)
					return true
				end
				trace("money not spawned yet")
				return false
			end

			for i = 1, artefact_count * af_skull_miser.money_items_num do
				local money_position = npc:position()
				local money_direction = npc:direction()
				money_direction = vector_rotate_y(money_direction, random(-180, 180))
				money_position.x = money_position.x + money_direction.x * random_float(0.3, 0.5)
				money_position.y = money_position.y + money_direction.y + 2
				money_position.z = money_position.z + money_direction.z * random_float(0.3, 0.5)
				local money_item = alife_create_item(get_random_array_element(money_items), {money_position, npc_level_vertex_id, npc_game_vertex_id, nil})
				CreateTimeEvent(money_item.id, money_item.id, 0, money_fountain, money_item.id)
			end

			artefact_props.af_lucifer:change_condition(0.005)
		end,
	},

	-- Claw, Perk: Bloodlust
	af_kogot = {
		get_sections = function(self, artefact) return artefact_props.af_kogot.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, who, last_npc_hit, last_npc_hit_bone_index)
			artefact_props.af_kogot:on_death(actor, artefact, artefact_count, artefact_ids, artefact_names, npc, who, last_npc_hit, last_npc_hit_bone_index)
		end,
	},

	-- Dragon's Eye, Perk: Good ol' Ultra-Violence
	af_dragon_eye = {
		get_sections = function(self, artefact) return artefact_props.af_dragon_eye.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, who, last_npc_hit, last_npc_hit_bone_index)
			artefact_props.af_dragon_eye:on_death(actor, artefact, artefact_count, artefact_ids, artefact_names, npc, who, last_npc_hit, last_npc_hit_bone_index)
		end,
	},

	-- Beacon, Perk: The Unorthodox Way of Travelling
	af_lighthouse = {
		get_sections = function(self, artefact) return artefact_props.af_lighthouse.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, who, last_npc_hit, last_npc_hit_bone_index)
			artefact_props.af_lighthouse:on_death(actor, artefact, artefact_count, artefact_ids, artefact_names, npc, who, last_npc_hit, last_npc_hit_bone_index)
		end,
	},
}

-- Functions for artefacts which provide perk bonuses on before monster hit
artefact_on_monster_before_hit_functions = {

	-- Claw, Perk: Bloodlust
	af_kogot = {
		get_sections = function(self, artefact) return artefact_props.af_kogot.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
			artefact_props.af_kogot:on_before_hit(actor, artefact, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
		end,
	},

	-- Dragon's Eye, Perk: Good ol' Ultra-Violence
	af_dragon_eye = {
		get_sections = function(self, artefact) return artefact_props.af_dragon_eye.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
			artefact_props.af_dragon_eye:on_before_hit(actor, artefact, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
		end,
	},

	-- Spike, Perk: Critical Ascensi0n
	af_spaika = {
		get_sections = function(self, artefact) return artefact_props.af_spaika.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
			artefact_props.af_spaika:on_before_hit(actor, artefact, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
		end,
	},

	-- Sandstone, perk: Zone Infusion
	af_sandstone = {
		get_sections = function(self, artefact) return artefact_props.af_sandstone.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
			artefact_props.af_sandstone:on_before_hit(actor, artefact, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
		end,
	},

	-- Thistle, perk: Minor Laceration
	af_repei = {
		get_sections = function(self, artefact) return artefact_props.af_repei.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
			artefact_props.af_repei:on_before_hit(actor, artefact, artefact_count, artefact_ids, artefact_names, monster, s_hit, bone_id, flags)
		end,
	},

	-- Sun, Perk: Solar Powered
	af_sun = {
		get_sections = function(self, artefact) return artefact_props.af_sun.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
			artefact_props.af_sun:on_before_hit(actor, artefact, artefact_count, artefact_ids, artefact_names, npc, s_hit, bone_id, flags)
		end,
	},
}

-- Functions for artefacts which provide perk bonuses on monster hit
artefact_on_monster_hit_functions = {

	-- Thistle, perk: Minor Laceration
	af_repei = {
		get_sections = function(self, artefact) return artefact_props.af_repei.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, monster, amount, local_direction, who, bone_index, last_monster_hit)
			artefact_props.af_repei:on_hit(actor, artefact, artefact_count, artefact_ids, artefact_names, monster, amount, local_direction, who, bone_index, last_monster_hit)
		end,
	},
}

-- Functions for artefacts which provide perk bonuses on monster death
artefact_on_monster_death_functions = {

	-- Claw, Perk: Bloodlust
	af_kogot = {
		get_sections = function(self, artefact) return artefact_props.af_kogot.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, monster, who, last_monster_hit, last_monster_hit_bone_index)
			artefact_props.af_kogot:on_death(actor, artefact, artefact_count, artefact_ids, artefact_names, monster, who, last_monster_hit, last_monster_hit_bone_index)
		end,
	},

	-- Dragon's Eye, Perk: Good ol' Ultra-Violence
	af_dragon_eye = {
		get_sections = function(self, artefact) return artefact_props.af_dragon_eye.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, monster, who, last_monster_hit, last_monster_hit_bone_index)
			artefact_props.af_dragon_eye:on_death(actor, artefact, artefact_count, artefact_ids, artefact_names, monster, who, last_monster_hit, last_monster_hit_bone_index)
		end,
	},

	-- Beacon, Perk: The Unorthodox Way of Travelling
	af_lighthouse = {
		get_sections = function(self, artefact) return artefact_props.af_lighthouse.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, monster, who, last_monster_hit, last_monster_hit_bone_index)
			artefact_props.af_lighthouse:on_death(actor, artefact, artefact_count, artefact_ids, artefact_names, monster, who, last_monster_hit, last_monster_hit_bone_index)
		end,
	},
}

-- Functions for artefacts which provide perk bonuses on trade
artefact_on_trade_functions = {

	-- Fountain, Perk: Letyshops Time
	af_fountain = {
		get_sections = function(self, artefact) return artefact_props.af_fountain.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, item, sell_bye)
			if sell_bye then
				actor_last_money = actor:money()
				trace("Fountain not fired, selling item")
				return
			end

			local af_fountain = artefact_props.af_fountain

			if af_fountain.cashback_triggered then
				ResetTimeEvent("af_fountain_cashback", "af_fountain_cashback", 0.15)
			else
				trace("Fountain fired")

				local function cashback()
					local money = actor:money()
					trace("Actor last money %s, actor current money %s", actor_last_money, money)
					local cashback = round((actor_last_money - money) * af_fountain.cashback_bonus * artefact_count)
					if cashback < 1 then
						trace("Fountain not fired, not enough money")
						actor_last_money = money
						return true
					end

					trace("Fountain, Money given %s", cashback)
					actor:give_money(cashback)

					local news_text = translate_string(tostring(cashback))
					local news_caption = translate_string("general_in_money")
					local news_ico = "ui_inGame2_Dengi_polucheni"
					xr_sound.set_sound_play(AC_ID, "pda_tips")
					actor:give_game_news(news_caption, news_text, news_ico, 0, 7000, 0)

					af_fountain.cashback_triggered = false
					actor_last_money = actor:money()

					ui_inventory.GUI:On_Item_Update()
					return true
				end

				CreateTimeEvent("af_fountain_cashback", "af_fountain_cashback", 0.15, cashback)
				af_fountain.cashback_triggered = true
			end
		end,
	},
}

-- Functions for artefacts which provide perk on drag drop
artefact_on_item_drag_dropped_functions = {
	-- Sandstone, perk: Zone Infusion
	af_sandstone = {
		get_sections = function(self, artefact) return artefact_props.af_sandstone.sections end,
		func = function(self, actor, artefact, obj_1, obj_2, slot_from, slot_to)
			if not IsWeapon(obj_2) then 
				trace("Sandstone, target is not weapon, %s", obj_2:section())
				return
			end

			-- Reset if melee weapon or binocs
			if IsMelee(obj_2) or IsItem("fake_ammo_wpn", obj_2:section()) or IsBinoc(obj_2:section()) then
				trace("Sandstone, target is knife or binocs, %s", obj_2:section())
				return
			end

			-- Reset if throwable weapon (grenade, bolt)
			if IsBolt(obj_2) or IsGrenade(obj_2) then
				trace("Sandstone, target is throwable, %s", obj_2:section())
				return
			end

			local af_sandstone = artefact_props.af_sandstone
			local hit_type = af_sandstone:get_valid_hit_type()

			add_status_effect(600, {
				weapon_name = obj_2:name(),
				hit_type = hit_type,
				hit_type_icon = af_sandstone.hit_types_icons[hit_type],
			}, "af_sandstone" .. obj_2:name())
			
			add_virtual_artefact(artefact)
			add_timed_effect(600, nil, nil, function(artefact)
				perk_based_artefacts.remove_virtual_artefact(artefact)
			end, {artefact}, "af_sandstone_remove_virtual_artefact")
			play_sound_on_actor(get_random_array_element(af_sandstone.hit_types_sounds[hit_type]), 0.7, random_float(0.95, 1.05))
			alife_release(obj_1)
		end,
	},

	--Bat, Perk: Zone Alchemy
	af_bat = {
		get_sections = function(self, artefact) return artefact_props.af_bat.sections end,
		func = function(self, actor, artefact, obj_1, obj_2, slot_from, slot_to)
			if bat_transmutate_func.check_transmutate(obj_2, nil, "inventory") then
				bat_transmutate_func.transmutate_func(obj_2, nil, "inventory")
			end
		end,
	},
}

-- Functions for artefacts which provide perk bonuses on equip
artefact_on_equip_functions = {

	-- Heart, Perk: Will to Live
	af_ear = {
		get_sections = function(self, artefact) return artefact_props.af_ear.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local af_ear = artefact_props.af_ear
			af_ear:sound_play()
			register_on_equip_callback("actor_on_first_update", function() end, function()
				af_ear:sound_stop()
			end, "af_ear")
		end,
	},

	-- Phantom Star, Perk: Phantom Pacifist
	af_star_phantom = {
		get_sections = function(self, artefact) return artefact_props.af_star_phantom.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local af_star_phantom = artefact_props.af_star_phantom
			if not af_star_phantom.weapon_hidden then
				af_star_phantom:hide_weapon()
			end
			af_star_phantom:add_pp_effector()

			af_star_phantom.used_artys = artefact_ids
			add_ui_func(
				artefact,
				true,
				artefact,
				function() return perk_based_artefacts.artefact_props.af_star_phantom:ui_text_func() end,
				function() return perk_based_artefacts.artefact_props.af_star_phantom:ui_validate_func() end
			)

			RemoveTimeEvent("af_star_phantom_on_enemy_eval_unreg", 0)
			register_callback("on_enemy_eval", af_star_phantom.ignore_enemy_function, nil, "af_star_phantom")
			register_on_equip_callback("actor_on_first_update", nil, function()
				af_star_phantom:restore_weapon()
				af_star_phantom:remove_pp_effector()
				remove_ui_func("af_star_phantom")
				CreateTimeEvent("af_star_phantom_on_enemy_eval_unreg", 0, 1.5, function()
					unregister_callback("af_star_phantom")
					return true
				end)
			end, "af_star_phantom")
		end,
	},

	-- Generator, Perk: Godzilla is Approaching
	af_generator = {
		get_sections = function(self, artefact) return artefact_props.af_generator.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			add_speed(speed_boosts.af_generator.name, 1 + speed_boosts.af_generator.boost * (artefact_count - 1), true, true)
		end,
	},

	-- Ball, Perk: Kick Deez Nutz
	af_ball = {
		get_sections = function(self, artefact) return artefact_props.af_ball.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local af_ball = artefact_props.af_ball
			empty_table(af_ball.monsters)
			for i = 1, min(5, artefact_count) do
				for j, monster in ipairs(af_ball.monster_tiers[i]) do
					af_ball.monsters[monster] = true
				end
			end
		end,
	},

	-- Seraphim, Perk: Rain of Revival
	af_serofim = {
		get_sections = function(self, artefact) return artefact_props.af_serofim.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local ironman = alife_storage_manager.get_state().ironman
			if ironman and ironman.death_count then
				trace("ironman is active, saving death count %s, death limit %s", ironman.death_count, ironman.death_limit)
				artefact_props.af_serofim.ironman_death_count = ironman.death_count
			end
		end,
	},

	-- Lamp, Perk: Enlightening Kleptomania
	af_fonar = {
		get_sections = function(self, artefact) return artefact_props.af_fonar.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			local rf_stashes = item_radio.RF_stashes

			if rf_stashes[actor_level] then
				for k, v in pairs(rf_stashes[actor_level]) do
					local obj = get_object_by_id(k)
					if obj then
						local pos = obj:position()
						trace("stash id %s, freq %s, coords %s %s %s", k, v, pos.x, pos.y, pos.z)
					end
				end
			end

			local af_fonar = artefact_props.af_fonar
			RegisterScriptCallback("actor_on_item_take", af_fonar.on_item_take)
			register_on_equip_callback("actor_on_update", af_fonar.light_sources_update, function()
				for k, v in pairs(af_fonar.light_sources) do
					local light = v.light
					light.enabled = false
					light:update()
					af_fonar.light_sources[k] = nil
				end
				af_fonar.targets = nil
				UnregisterScriptCallback("actor_on_item_take", af_fonar.on_item_take)
			end, "af_fonar")
		end,
	},

	-- Knot, Perk: Deal with the Devil
	af_fire_loop = {
		get_sections = function(self, artefact) return artefact_props.af_fire_loop.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names)
			if not has_alife_info("lucifer_active") then
				alife_create_item("af_lucifer", actor)
				alife_release_id(artefact_ids[1])
				give_info("lucifer_active")
				play_sound_on_actor("perk_based_artefacts\\creep_laugh")
				CreateTimeEvent("lucifer_activate", "lucifer_activate", 0.15, function()
					force_refresh_state()
					CreateTimeEvent("lucifer_activate2", "lucifer_activate2", 0.15, function()
						ui_inventory.GUI:UpdateWeight()
						return true
					end)
					return true
				end)
			end
		end,
	},
}

-- Functions for artefacts which provide perk bonuses for helicopter hits specifically
artefact_on_heli_hit_functions = {
	-- Dragon's Eye
	af_dragon_eye = {
		get_sections = function(self, artefact) return artefact_props.af_dragon_eye.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, heli, amount, who)
			artefact_props.af_dragon_eye:on_heli_hit(actor, artefact, artefact_count, artefact_ids, artefact_names, heli, who)
		end,
	},
}

-- Functions for artefacts which provide perk bonuses for animations
artefact_on_hud_animation_play_functions = {

	-- Claw, Perk: Bloodlust
	af_kogot = {
		get_sections = function(self, artefact) return artefact_props.af_kogot.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, anm_table, obj)
			local af_kogot = artefact_props.af_kogot
			if IsMelee(obj) and af_kogot.anims_to_accelerate[anm_table.anm_name] then
				anm_table.anm_speed = anm_table.anm_speed * (1 + 0.5 * artefact_count)
			end
		end,
	},
}

-- Functions for artefacts which provide perk bonuses for bullets
artefact_bullet_on_init_functions = {
	-- Spike
	af_spaika = {
		get_sections = function(self, artefact) return artefact_props.af_spaika.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, bullet)
			local af_spaika = artefact_props.af_spaika
			local tg = time_global()
			af_spaika.bullet_groups[tg] = af_spaika.bullet_groups[tg] or {}
			table_insert(af_spaika.bullet_groups[tg], bullet)
		end,
	},
}
artefact_bullet_on_impact_functions = {
	-- Spike
	af_spaika = {
		get_sections = function(self, artefact) return artefact_props.af_spaika.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, bullet)
			local af_spaika = artefact_props.af_spaika
			local obj = get_object_by_id(bullet.target_id)
			trace("Spike, Bullet impact")
			if obj and (IsMonster(obj) or IsStalker(obj)) and obj:alive() then
				af_spaika:add_bullet_group_to_hitted_bullets(bullet)
			end
		end,
	},
}
artefact_bullet_on_remove_functions = {
	-- Spike
	af_spaika = {
		get_sections = function(self, artefact) return artefact_props.af_spaika.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, bullet)
			local af_spaika = artefact_props.af_spaika
			trace("Spike, Bullet remove")
			if af_spaika.hitted_bullets[bullet.bullet_id] then
				af_spaika.hitted_bullets[bullet.bullet_id] = nil
			else
				af_spaika:effect_reset()
			end
			af_spaika:remove_bullet_from_bullet_group(bullet)
		end,
	},
}

-- Functions for artefacts on key press
artefact_on_key_press_functions = {
	-- Ball
	af_ball = {
		get_sections = function(self, artefact) return artefact_props.af_ball.sections end,
		func = function(self, actor, artefact, artefact_count, artefact_ids, artefact_names, key)
			local af_ball = artefact_props.af_ball
			if not check_cooldown(af_ball.cooldown_name) then return end

			local bind = dik_to_bind(key)
			if (bind == key_bindings.kUSE) then
				local distance = math.huge
				local target
				local pointed = level.get_target_obj()
				level.iterate_nearest(actor:position(), af_ball.scan_radius + 1, function(obj)
					if not 
					(
						obj:id() ~= AC_ID
						and (
							(IsMonster(obj) and 
							(
								af_ball.monsters[obj:clsid()] or af_ball.monsters[SYS_GetParam(
									2,
									obj:section(),
									"kind",
									"definitely_not_found_kind"
								)]
							))
							-- or (IsStalker(obj) and xr_combat_ignore.fighting_with_actor_npcs[obj:id()])
						)
						and obj:alive()
						and obj:position():distance_to(actor:position()) <= af_ball.scan_radius
					) then
						-- printf("target %s is invalid", obj:name())
						return
					end

					-- Pointed target takes priority
					if pointed and pointed:id() == obj:id() then
						-- printf("target %s is pointed", obj:name())
						target = obj
						return true
					end

					local pos = obj:position()

					-- Visibility check, position or obj bones
					local visibility_checks = {
						function()
							local see = game.world2ui(obj:position())
							return (see.x > 0 and see.x < 1024 and see.y > 0 and see.y < 1024)
						end,
						function()
							local pos = utils_obj.safe_bone_pos(obj, "bip01_spine")
							if not (pos and pos.x ~= 0 and pos.y ~= 0 and pos.z ~= 0) then return end

							local see = game.world2ui(pos)
							return (see.x > 0 and see.x < 1024 and see.y > 0 and see.y < 1024)
						end,
						function()
							local pos = utils_obj.safe_bone_pos(obj, "bip01_head")
							if not (pos and pos.x ~= 0 and pos.y ~= 0 and pos.z ~= 0) then return end

							local see = game.world2ui(pos)
							return (see.x > 0 and see.x < 1024 and see.y > 0 and see.y < 1024)
						end,
					}
					local see = false
					for i, v in ipairs(visibility_checks) do
						if v() then
							see = true
							break
						end
					end
					if not see then
						-- printf("cant see")
						return
					end

					-- Obstacle check, rays
					local obstacle_checks = {
						function()
							local ray = demonized_geometry_ray.geometry_ray({
								ray_range = 200,
								ignore_object = obj,
								flags = 3,
							})
							local res = ray:get(pos, actor:position():sub(pos):normalize())
							return res.result and res.result.object and res.result.object:id() == AC_ID
						end,
						function()
							local p = utils_obj.safe_bone_pos(actor, "bip01_spine")
							if not (p and p.x ~= 0 and p.y ~= 0 and p.z ~= 0) then return end

							local ray = demonized_geometry_ray.geometry_ray({
								ray_range = 200,
								ignore_object = obj,
								flags = 3,
							})
							local res = ray:get(pos, p:sub(pos):normalize())
							return res.result and res.result.object and res.result.object:id() == AC_ID
						end,
					}
					local no_obstacle = false
					for i, v in ipairs(obstacle_checks) do
						if v() then
							no_obstacle = true
							break
						end
					end
					if not no_obstacle then
						-- printf("obstacled")
						return
					end

					local dist = pos:distance_to_sqr(actor:position())
					if dist < distance then
						distance = dist
						target = obj
					end
				end)
				if not target then return end

				local pos = actor:position()
				local h = hit()
				local direction = device().cam_dir
				local magnitude = artefact_count * 60
				direction.x = direction.x * 1000 * magnitude
				direction.y = random_float(0.1, 0.2) * 5000 * magnitude
				direction.z = direction.z * 1000 * magnitude
				h.power = 10000
				h.direction = direction
				h.bone = "bip01_spine"
				h.draftsman = actor
				h.impulse = 10000	--6000
				h.type = hit.wound
				target:hit(h)

				local obj_id = target:id()

				local function fly(obj_id)
					local monster = get_object_by_id(obj_id)
					if monster and not monster:alive() and monster:get_physics_shell() then
						trace("monster dead, physics shell works")
						monster:get_physics_shell():apply_force(direction.x, direction.y, direction.z)
						play_sound_on_actor("perk_based_artefacts\\BIGGIB0" .. random(6), 1, random_float(0.9, 1.0))
						local position = monster:position()
						position.y = position.y + 1

						if artefact_count < 2 then
							play_sound_on_actor("perk_based_artefacts\\BONSNAP" .. random(8), 0.1 + 0.2 * (artefact_count - 1), random_float(0.9, 1.0))
							local gibs = particles_object("artefact\\effects\\af_idle_dist")
							if gibs and not gibs:playing() then
								gibs:play_at_pos(position)
							end
						elseif artefact_count < 4 then
							play_sound_on_actor("perk_based_artefacts\\BONSNAP" .. random(8), 0.7, random_float(0.9, 1.0))
							local gibs = particles_object("artefact\\artefact_mincer")
							if gibs and not gibs:playing() then
								gibs:play_at_pos(position)
							end
						else
							play_sound_on_actor("perk_based_artefacts\\GNTEAR0" .. random(2), 0.75, random_float(0.9, 1.0))
							local gibs = particles_object("artefact\\artefact_gravi")
							if gibs and not gibs:playing() then
								gibs:play_at_pos(position)
							end
						end

						return true
					end
					trace("monster not dead yet")
					return false
				end
				CreateTimeEvent("af_bat_fly" .. obj_id, obj_id, 0, fly, obj_id)

				add_cooldown(IsStalker(target) and 5 or (1 + 1 * artefact_count), af_ball.cooldown_name)
				add_ui_func(
					artefact,
					false,
					artefact,
					function() return perk_based_artefacts.artefact_props.af_ball:ui_text_func() end,
					function() return perk_based_artefacts.artefact_props.af_ball:ui_validate_func() end
				)
			end
		end,
	},
}

artefact_binder_on_update_functions = {
	-- Medal, Perk: Hacksaw
	af_medallion = function(binder)
		if binder.destroyed then
			if settings.debug_mode then
				-- level.remove_cam_custom_position_direction()
			end
			
			if binder.sound_idle then binder.sound_idle:stop() end
			return
		end

		local obj = binder.object
		local id = obj:id()
		
		local props = se_load_var(id, nil, "af_medallion")
		if not props then
			return true
		end

		if obj:parent() then
			if settings.debug_mode then
				-- level.remove_cam_custom_position_direction()
			end
			
			if binder.sound_idle then binder.sound_idle:stop() end
			return true
		end

		if not binder.first_update_done then
			binder.first_update_done = true

			binder.target_current_id = nil
			binder.target_list = {}
			binder.target_radius = 45
			binder.target_radius_sqr = binder.target_radius ^ 2

			binder.attack_time = 70
			binder.attack_radius = 1.5
			binder.attack_radius_sqr = binder.attack_radius ^ 2

			binder.panic_time = 1.2
			binder.panic_radius = 7
			binder.panic_radius_sqr = binder.panic_radius ^ 2
			binder.panic_radius_non_targets = 2.5
			binder.panic_radius_non_targets_sqr = binder.panic_radius ^ 2
			
			binder.max_distance_from_actor_sqr = 80 ^ 2
			binder.take_distance_sqr = 1.6 ^ 2

			binder.homing_speed = 0.75
			binder.speed = 13
			binder.damage = 0.55

			binder.invalid_try_max = 25
			binder.invalid_try_count = 0

			binder.fly_direction = table2vec(props.fly_direction)
			binder.start_time = props.start_time
			binder.stop_time = props.start_time + binder.attack_time
			binder.return_home = props.return_home

			binder.sound_idle = sound_object("perk_based_artefacts\\FUNGFLY")
			binder.sound_idle:play_at_pos(obj, obj:position(), 0, sound_object.s3d + sound_object.looped)
			binder.sound_idle.frequency = 1

			binder.get_target_pos = function(target)
				local target_pos = utils_obj.safe_bone_pos(target, "bip01_head") or target:position():add(vector():set(0, 0.5, 0))
				return target_pos
			end

			local closest_distance = math.huge
			binder.target_list_func = function(target)
				if 	target:id() ~= AC_ID 
				and (IsMonster(target) or (
						IsStalker(target) 
						and (game_relations.is_factions_enemies(get_actor_true_community(), character_community(target)) or xr_combat_ignore.fighting_with_actor_npcs[target:id()])
						)
					)
				and target:alive()
				then
					local distance = distance_to_xz_sqr(obj:position(), binder.get_target_pos(target))
					if distance <= binder.target_radius_sqr then
						binder.target_list[target:id()] = distance
						if distance < closest_distance then

							-- Check for obstacles
							local ray = demonized_geometry_ray.geometry_ray({
								ray_range = binder.target_radius,
								ignore_object = obj,
								flags = 3,
								visualize = false,
							})
							local res = ray:get(obj:position(), binder.get_target_pos(target):sub(obj:position()):normalize())
							if res.in_contact and res.result and res.result.object and res.result.object:id() == target:id() then
								closest_distance = distance
								binder.target_current_id = target:id()
							end
						end
					end
				end
			end
			binder.target_update_func = throttle(function()
				if binder.return_home then
					binder.target_current_id = AC_ID
					return
				end

				if binder.target_current_id then
					return
				end

				closest_distance = math.huge
				empty_table(binder.target_list)
				level.iterate_nearest(obj:position(), 150, binder.target_list_func)

				-- If there is closest target but havent chosen because of obstacles, fly towards first found one
				if not binder.target_current_id and is_not_empty(binder.target_list) then
					local dist = math.huge
					for id, distance in pairs(binder.target_list) do
						if distance < dist then
							dist = distance
							binder.target_current_id = id
						end
					end
				end
			end, 400)

			binder.target_attack_func = throttle(function()
				if binder.return_home then
					local distance = obj:position():distance_to_sqr(binder.get_target_pos(db.actor))
					if distance < binder.take_distance_sqr then

						-- Play animation
						-- game.play_hud_motion(1, "af_medallion_grenade_hud", "anm_hands_catch", true, 1)
						-- level.add_cam_effector("camera_effects\\weapon\\barry_af_medallion_hands_catch.anm", 8539, false, "", 0, false)

						db.actor:take_item(obj)
					end
					return
				end

				if not binder.target_current_id then return end

				local target = get_object_by_id(binder.target_current_id)
				if not (target and target:alive()) then
					binder.target_current_id = nil
					return
				end

				local distance = obj:position():distance_to_sqr(binder.get_target_pos(target))

				if distance > binder.attack_radius_sqr then
					binder.invalid_try_count = binder.invalid_try_count + 1
					if binder.invalid_try_count > binder.invalid_try_max then
						binder.invalid_try_count = 0
						binder.target_current_id = nil
					end
					return
				end

				local s_hit = hit()
				s_hit.power = binder.damage
				s_hit.type = hit.wound
				s_hit.impulse = 1
				s_hit.direction = _G.VEC_Y
				s_hit.draftsman = db.actor

				target:hit(s_hit)

				-- Play hit sound
				local snd = sound_object("perk_based_artefacts\\hit_0" .. random(0, 9))
				snd:play_at_pos(obj, obj:position(), 0, sound_object.s3d)
				snd.frequency = random_float(0.9, 1.1)

				-- Play particles
				local particle = particles_object(get_random_array_element({
					"hit_fx\\hit_flesh_01",
					"hit_fx\\hit_flesh_02",
					"hit_fx\\hit_flesh_02a",
				}))
				particle:play_at_pos(obj:position())

				binder.invalid_try_count = 0
			end, 250)

			binder.target_panic_func = throttle(function()
				for id, _ in pairs(binder.target_list) do
					local target = get_object_by_id(id)
					if target and id ~= binder.target_current_id then
						local distance = obj:position():distance_to_sqr(binder.get_target_pos(target))
						if distance < binder.panic_radius_non_targets_sqr and IsStalker(target) then
							demonized_stalker_aoe_panic.npc_add_aoe_panic(target:id(), "af_medallion_panic", binder.panic_time, obj:position(), nil, 1.5)
						end
					end
				end

				if not binder.target_current_id then return end

				local target = get_object_by_id(binder.target_current_id)
				if not target then
					return
				end

				local distance = obj:position():distance_to_sqr(binder.get_target_pos(target))
				if distance < binder.panic_radius_sqr and IsStalker(target) then
					demonized_stalker_aoe_panic.npc_add_aoe_panic(target:id(), "af_medallion_panic", binder.panic_time, obj:position(), nil, 1.5)
				end
			end, binder.panic_time * 1000 - 200)

			binder.target_homing_func = throttle(function()
				if not binder.target_current_id then return end

				local target = get_object_by_id(binder.target_current_id)
				if not target then
					return
				end

				-- Homing function
				local pos = obj:position()				

				-- Get target direction
				local target_pos = binder.get_target_pos(target)
				local target_dir = target_pos:sub(pos):normalize()

				-- Get angle between target and current directions
				local angle = yaw_degree3d(binder.fly_direction, target_dir)

				-- Get interpolation based on homing speed
				local homing_speed = binder.homing_speed * device().time_delta
				local coeff = math.min(homing_speed / angle, 1)

				-- print_tip("projectile %s%s, homing to obj %s, angle %s, hom speed %s, coeff %s", self.section, self.weapon_id, obj:name(), angle, homing_speed, coeff)

				-- Interpolate between current dir and target dir
				binder.fly_direction = vector():set(
					lerp(binder.fly_direction.x, target_dir.x, coeff),
					lerp(binder.fly_direction.y, target_dir.y, coeff),
					lerp(binder.fly_direction.z, target_dir.z, coeff)
				):normalize()

				if settings.debug_mode then
					-- demonized_geometry_ray.VisualizeRay(obj:position(), obj:position():mad(binder.fly_direction, binder.get_target_pos(target):sub(obj:position()):magnitude()), nil, device().time_delta)
					-- demonized_geometry_ray.VisualizeRay(obj:position(), binder.get_target_pos(target), nil, device().time_delta)
				end
			end)

			binder.fly_func = throttle(function()

				-- Procedure to possibly unstuck Medallion from closed rooms
				local temp = vector():set(binder.fly_direction)
				local ray = demonized_geometry_ray.geometry_ray({
					ray_range = 200,
					ignore_object = obj,
					flags = 3,
				})
				local res = ray:get(obj:position(), binder.fly_direction)
				if res.result and res.result.object and res.result.object:id() == binder.target_current_id then
					RemoveTimeEvent("af_medallion_temp_lower_speed", obj:id())
					binder.homing_speed = binder.temp_homing_speed or binder.homing_speed
					binder.temp_homing_speed = nil
				else
					local ray = demonized_geometry_ray.geometry_ray({
						ray_range = 50,
						contact_range = 0.7,
						ignore_object = obj,
						flags = 3,
					})
					local res = ray:get(obj:position(), binder.fly_direction)
					if res.in_contact and (not res.result.object or (res.result.object and res.result.object:id() ~= binder.target_current_id)) then
						local surface_normal = demonized_geometry_ray.get_surface_normal(obj:position():mad(binder.fly_direction, 0.1), binder.fly_direction)
						if surface_normal then
							binder.fly_direction:reflect(binder.fly_direction, surface_normal)
							binder.fly_direction.y = binder.fly_direction.y + 0.5

							-- If stuck in corner - reflect Y and turn 60 degrees away from target
							local ray = demonized_geometry_ray.geometry_ray({
								ray_range = 50,
								contact_range = 0.7,
								ignore_object = obj,
								flags = 3,
							})
							local res = ray:get(obj:position(), binder.fly_direction)
							if res.in_contact and (not res.result.object or (res.result.object and res.result.object:id() ~= binder.target_current_id)) then
								binder.fly_direction.y = -binder.fly_direction.y

								if angle_left_xz(binder.fly_direction, temp) then
									temp = vector_rotate_y(temp, -60)
								else
									temp = vector_rotate_y(temp, 60)
								end

								binder.fly_direction:setHP(temp:getH(), binder.fly_direction:getP()):normalize()
								binder.temp_homing_speed = binder.temp_homing_speed or binder.homing_speed
								binder.homing_speed = 0.02
								CreateTimeEvent("af_medallion_temp_lower_speed", obj:id(), 1.2, function(homing_speed)
									binder.homing_speed = homing_speed
									return true
								end, binder.temp_homing_speed)
							end

							-- Possibly play sound
						end
					end
				end

				local dir = vector():set(binder.fly_direction):normalize()

				local mass = obj:mass()
				local speed = binder.speed * mass
				-- First person legs mod crutch
				if swm_legs then
					speed = speed * 80
				end

				obj:set_const_force(dir, speed, device().time_delta)

				if settings.debug_mode then
					-- level.set_cam_custom_position_direction(obj:position():mad(binder.fly_direction, -0.2), vector():set(binder.fly_direction:getH(), binder.fly_direction:getP(), 0))
				end
			end)

			-- Counter gravity force
			local mass = obj:mass()
			local dir = vector():set(0, 1, 0)
			obj:set_const_force(dir, mass * 19.62, 10000000)
		end

		binder.target_update_func()
		binder.target_attack_func()
		binder.target_panic_func()
		binder.target_homing_func()
		binder.fly_func()
		binder.sound_idle:set_position(obj:position())

		if (time_elapsed > binder.stop_time or obj:position():distance_to_sqr(binder.get_target_pos(db.actor)) > binder.max_distance_from_actor_sqr)
		-- Uncomment to persist until target dies - can be OP
		-- and not binder.target_current_id
		then
			if obj:condition() <= 0.05 then

				if settings.debug_mode then
					-- level.remove_cam_custom_position_direction()
				end

				binder.destroyed = true

				-- Play destroy sound
				local t = {}
	            local sounds = {
	                "perk_based_artefacts\\PLSDTH01",
	                "perk_based_artefacts\\PLSDTH02",
	                "perk_based_artefacts\\PLSDTH03",
	                "perk_based_artefacts\\PLSDTH04",
	                "perk_based_artefacts\\PLSDTH05",
	                "perk_based_artefacts\\PLSDTH06",
	                "perk_based_artefacts\\PLSDTH07",
	                "perk_based_artefacts\\PLSDTH08",
	                "perk_based_artefacts\\PLSDTH09",
	                "perk_based_artefacts\\PLSDTH10",
	            }
	            for i = 1, math.random(3) do
	                t[#t + 1] = table.remove(sounds, math.random(#sounds))
	            end
	            
	            for i, v in ipairs(t) do
	            	local o = sound_object(v)
	            	o:play_at_pos(obj, obj:position(), 0, sound_object.s3d)
	            end

	            alife_release_id(id)
				return
			end
			binder.return_home = true
		end

		props.fly_direction = vec2table(binder.fly_direction)
		props.return_home = binder.return_home
		se_save_var(id, nil, "af_medallion", props)
	end,
}

artefact_binder_on_destroy_functions = {
	-- Medal, Perk: Hacksaw
	af_medallion = function(binder)
		if binder.first_update_done then
			binder.sound_idle:stop()
		end
	end
}

-- Functors for Bat, Perk: Zone Alchemy
local add_functor = custom_functor_autoinject.add_functor
local override_functor = custom_functor_autoinject.override_functor
bat_transmutate_func = {
	check_transmutate = function(obj, bag, mode)
		local modes = {
			["inventory"] = true,
			["loot"] = true,
		}
		local af_bat = artefact_props.af_bat
		local sec = obj:section()
		return IsArtefact(obj) and af_bat:check_bat() and af_bat.allow_artefacts[sec] and not af_bat.ignore_artefacts[sec] and modes[mode]
	end,
	transmutate_string = function(obj, bag, mode)
		return "st_pba_transmutate"
	end,
	transmutate_func = function(obj, bag, mode)
		return artefact_props.af_bat:transmutate_artefact(obj)
	end
}
add_functor("pba_bat", bat_transmutate_func.check_transmutate, bat_transmutate_func.transmutate_string, nil, bat_transmutate_func.transmutate_func, true)

-- Functors for Beacon
af_lighthouse_user_teleport_func = {
	check = function(obj, bag, mode)
		return artefact_props.af_lighthouse.sections[obj:section()]
	end,
	string = function(obj, bag, mode)
		return "st_pba_engage"
	end,
	action = function(obj, bag, mode)
		return perk_based_artefacts_af_choose_ui.start(obj, "st_pba_teleport_choose")
	end,
}
add_functor("pba_lighthouse", af_lighthouse_user_teleport_func.check, af_lighthouse_user_teleport_func.string, nil, af_lighthouse_user_teleport_func.action)

-- Functors for Dragon Eye
af_dragon_eye_engage_func = {
	check = function(obj, bag, mode)
		return artefact_props.af_dragon_eye.sections[obj:section()]
	end,
	string = function(obj, bag, mode)
		return "st_pba_engage"
	end,
	action = function(obj, bag, mode)
		db.actor:drop_item(obj)
		return perk_based_artefacts_af_choose_ui.start(obj, "st_pba_dragon_eye_engage")
	end,
}
add_functor("pba_dragon_eye", af_dragon_eye_engage_func.check, af_dragon_eye_engage_func.string, nil, af_dragon_eye_engage_func.action)

-- Functors for Medallion
af_medallion_engage_func = {
	check = function(obj, bag, mode)
		return artefact_props.af_medallion.sections[obj:section()]
	end,
	string = function(obj, bag, mode)
		return "st_pba_engage"
	end,
	action = function(obj, bag, mode)
		zzz_ui_inventory_arte_to_grenade.move_arte_to_grenade(obj)
	end,
}
add_functor("pba_medallion", af_medallion_engage_func.check, af_medallion_engage_func.string, nil, af_medallion_engage_func.action)

-- Functors for Cell
af_cell_engage_func = {
	check = function(obj, bag, mode)
		return artefact_props.af_cell.sections[obj:section()]
	end,
	string = function(obj, bag, mode)
		return "st_pba_engage"
	end,
	action = function(obj, bag, mode)
		zzz_ui_inventory_arte_to_grenade.move_arte_to_grenade(obj)
	end,
}
add_functor("pba_cell", af_cell_engage_func.check, af_cell_engage_func.string, nil, af_cell_engage_func.action)

-- Functors for Lucifer
lucifer_sacrifice_func = {
	check_lucifer_condition = function(obj, bag, mode)
		local modes = {
			["inventory"] = true,
			["loot"] = true,
		}
		local af_lucifer = artefact_props.af_lucifer
		local sec = obj:section()
		return IsArtefact(obj) and af_lucifer:check_lucifer() and af_lucifer.allow_artefacts[sec] and not af_lucifer.ignore_tiers[sec] and modes[mode]
	end,
	check_sacrifice = function(obj, bag, mode)
		return "st_pba_sacrifice"
	end,
	lucifer_sacrifice = function(obj, bag, mode)
		return artefact_props.af_lucifer:sacrifice_artefact(obj)
	end,
}
add_functor("pba_lucifer", lucifer_sacrifice_func.check_lucifer_condition, lucifer_sacrifice_func.check_sacrifice, nil, lucifer_sacrifice_func.lucifer_sacrifice, true)

-------------------------------------------------------------------------
-- Special monkey patches for some artefacts to make their effects work
-- Patch for First Person Death
if ayykyu_fp_death and ayykyu_fp_death.actor_on_before_death then
	local fp_death = ayykyu_fp_death.actor_on_before_death
	ayykyu_fp_death.actor_on_before_death = function(whoID, flags)
		for artefact, props in pairs(artefacts) do
			for perk, t in pairs(artefact_on_before_death_functions) do
				if type(t) == "function" then 
					if artefact == perk then
						return
					end
				else
					local sections = t.get_sections and t:get_sections(artefact)
					if not sections then
						sections = {[perk] = true}
					end
					if sections[artefact] then
						return -- prevent dying with First Person Death mod enabled
					end
				end
			end
		end
		fp_death(whoID, flags)
	end
end

-- Patch for Food Drug Drink Animations
if enhanced_animations and enhanced_animations.use_item and enhanced_animations.call_my_slot_back then

	local af_star_phantom = artefact_props.af_star_phantom

	local fdda_use_item = enhanced_animations.use_item
	enhanced_animations.use_item = function(obj)
		if has_artefacts_for_prop("af_star_phantom") then
			trace("restoring item")
			af_star_phantom:restore_weapon()
		end
		fdda_use_item(obj)
	end

	local fdda_call_my_slot_back = enhanced_animations.call_my_slot_back
	enhanced_animations.call_my_slot_back = function()
		fdda_call_my_slot_back()
		if has_artefacts_for_prop("af_star_phantom") then
			trace("hiding item")
			af_star_phantom:hide_weapon()
		end
		return true
	end

end

-- Patch for FDDA Backpack Animations
if zzz_ea_addon_backpack and zzz_ea_addon_backpack.call_my_slot_back then

	local af_star_phantom = artefact_props.af_star_phantom

	local call_my_slot_back = zzz_ea_addon_backpack.call_my_slot_back
	zzz_ea_addon_backpack.call_my_slot_back = function()
		call_my_slot_back()
		if has_artefacts_for_prop("af_star_phantom") then
			af_star_phantom:hide_weapon()
		end
		return true
	end

end

-- Patch for Quick Throw
local quick_throw = actor_effects.Hit_GrenadeQuickthrow
actor_effects.Hit_GrenadeQuickthrow = function()
	if has_artefacts_for_prop("af_star_phantom") then return end -- Phantom Pacifist perk to prevent quick throwing a grenade
	quick_throw()
end

-- Patch for Quick Melee
if quickdraw and quickdraw.hit_key then
	local quick_melee = quickdraw.hit_key
	quickdraw.hit_key = function()
		if has_artefacts_for_prop("af_star_phantom") then return end -- Phantom Pacifist perk to prevent quick melee with that mod enabled
		quick_melee()
	end
end

-- Patch for crow binder
local crow_death = bind_crow.crow_binder.death_callback
bind_crow.crow_binder.death_callback = function(self, victim, who)
	if has_artefacts_for_prop("af_lighthouse") and who and who:id() == AC_ID and victim then
		local props = get_first_artefact_for_prop("af_lighthouse")
		artefact_props.af_lighthouse:on_death(db.actor, "af_lighthouse", props.count, props.ids, props.names, victim, who, nil, nil)
	end	
	crow_death(self, victim, who)
end

-- Patch to not trigger lighthouse for emission crow kills
function make_dead_crow(id,powr)
	local crow = id and get_object_by_id(id)
	if(crow and crow.alive and crow:alive() and powr) then
		powr.draftsman = crow
		crow:hit(powr)
	end
	return true
end

function surge_manager.CSurgeManager:kill_crows_at_pos(pos,delay) -- hit all crows if their pos is bigger than "pos"
	local h = hit()
	h.type = hit.fire_wound
	h.power = 0.9
	h.impulse = 0.0
	h.direction = VEC_Z
--	h.draftsman = db.actor
	for k,id in pairs(bind_crow.crow_storage) do
		if delay then
			CreateTimeEvent("delay_kill_crow", id, random(3), make_dead_crow, id, h)
		else
			local crow = get_object_by_id(id)
			if (crow and crow.alive and crow:alive() and pos < crow:position().z) then
				h.draftsman = crow
				crow:hit(h)
			end
		end
	end
end

function psi_storm_manager.CPsiStormManager:kill_crows_at_pos(pos)
	--self.crowParticles={}
	local h = hit()
	h.type = hit.fire_wound
	h.power = 1.0
	h.impulse = 0
	h.direction = VEC_Z
--	h.draftsman = db.actor
	for k,v in pairs(bind_crow.crow_storage) do
		local obj = alife_object(v)
		if obj then
			local crow = get_object_by_id(obj.id)
			if(crow and crow.alive and crow:alive() and distance_2d(pos, crow:position())<25) then
				--crow:start_particles("crommcruac\\electrocute_crow","bip01_pelvis")
				--self.crowParticles[k]=particles_object("crommcruac\\electrocute_crow")
				--self.crowParticles[k]:play_at_pos(crow:position())
				h.draftsman = crow
				crow:hit(h)
			end
		end
	end
end

-- Disable talk possibility for Phantom Pacifist
local process_npc_usability = xr_meet.process_npc_usability
xr_meet.process_npc_usability = function(npc)
	if has_artefacts_for_prop("af_star_phantom") or check_status_effect("af_moh_invisibility") then
		npc:disable_talk()
		return
	end
	process_npc_usability(npc)
end

-- Disable npc evaluation for Phantom Pacifist
local evaluate = xr_meet.evaluator_contact.evaluate
xr_meet.evaluator_contact.evaluate = function(self)
	if has_artefacts_for_prop("af_star_phantom") or check_status_effect("af_moh_invisibility") then return false end
	return evaluate(self)
end

-- Azazel mode patching
local azazel_on_before_death = gamemode_azazel.actor_on_before_death
gamemode_azazel.actor_on_before_death = function(whoID,flags)
	if not alife_storage_manager.get_state().enable_azazel_mode then
		return
	end

	if has_artefacts_for_prop("af_serofim") then
		return
	end
	remove_lucifer()

	azazel_on_before_death(whoID, flags)
end

-- Removing stack effects on refreshing artefacts
function remove_stack_effects()
	if not has_artefacts_for_prop("af_spaika") then
		artefact_props.af_spaika:stack_reset()
	end
end

-- Process artefacts
process_artefacts = function(perk_table, ...)
	for artefact, props in pairs(artefacts) do
		for perk, t in pairs(perk_table) do
			if type(t) == "function" then
				if artefact == perk then
					t(db.actor, artefact, props.count, props.ids, props.names, ...)
					break
				end
			else
				local sections = t.get_sections and t:get_sections(artefact)
				if not sections then
					sections = {[perk] = true}
				end
				if sections[artefact] then
					trace("artefact %s", artefact)
					t:func(db.actor, artefact, props.count, props.ids, props.names, ...)
					break
				end
			end
		end
	end
end

-- Refreshing state
refresh_state = function()
	if refresh_artefacts() then
		remove_speed_boosts()
		remove_jump_boosts()
		remove_stack_effects()
		unregister_on_equip_callbacks()
		process_artefacts(artefact_on_equip_functions)
	end
end

force_refresh_state = function()
	refresh_artefacts(true)
	remove_speed_boosts()
	remove_jump_boosts()
	remove_stack_effects()
	unregister_on_equip_callbacks()
	process_artefacts(artefact_on_equip_functions)
	return true
end

function actor_on_item_use(obj, str)
	trace("actor_on_item_use, item %s", obj:section())

	process_artefacts(artefact_on_item_use_functions, obj)
end

-- Sanity check for unwanted effects
function sanity_check()
	check_status_effect("af_moh_invisibility")
	if not has_artefacts_for_prop("af_star_phantom") then
		unregister_on_equip_callback("af_star_phantom")
		local af_star_phantom = artefact_props.af_star_phantom
		af_star_phantom:reset_state()
	end
end

local degradation_time = 0
local degradation_time_interval = 20

degradation_valid_artys = (function()
	local t = {}
	ini_sys:section_for_each(function(sec)
		local s = get_artefact_from_container(sec)
		if 	SYS_GetParam(0, s, "kind", "") == "i_arty_junk" and
			not (s == "af_lucifer" or s == "af_star_phantom") then
			t[sec] = true
		end
	end)
	return t
end)()

function degradate_artefact(obj, timed_degradation)
	local sec = obj:section()
	if degradation_valid_artys[sec] then
		local cond = obj:condition()
		local new_cond = cond - timed_degradation * 0.001
		trace("%s is valid for degradation, cond %s, new_cond %s", sec, cond * 100, new_cond * 100)
		obj:set_condition(new_cond)
		if obj:condition() < 0.01 then
			trace("%s is critical, releasing, cond %s", sec, obj:condition() * 100)
			alife_release(obj)
			CreateTimeEvent("refresh_artefacts", "refresh_artefacts", 0.15, refresh_artefacts_time_event_func, true)
		end
	end
end

local function degradate_belt_function(owner, artefact)
	degradate_artefact(artefact, settings.timed_degradation)
end

local sanity_time = 0
local sanity_time_interval = 10
function actor_on_update()
	tg = floor(time_global() * 0.01)
	--trace("current tg %s", tg)
	if tg < actor_on_update_time then return end
	actor_on_update_time = tg + actor_on_update_timer

	time_elapsed = get_time_elapsed()
	--trace("current time_elapsed %s", time_elapsed)
	process_artefacts(artefact_on_update_functions)
	process_timed_effects()

	if tg > sanity_time then
		sanity_check()
		sanity_time = tg + sanity_time_interval
	end

	if settings.timed_degradation > 0 and tg > degradation_time then
		db.actor:iterate_belt(degradate_belt_function)
		degradation_time = tg + degradation_time_interval
	end

	saved_time_elapsed = time_elapsed
end

function actor_on_weapon_fired(obj, wpn, ammo_elapsed, grenade_elapsed, ammo_type, grenade_type)
	trace("weapon fired %s", wpn:section())

	process_artefacts(artefact_on_weapon_fired_functions, obj, wpn, ammo_elapsed, grenade_elapsed, ammo_type, grenade_type)
end

function actor_on_before_hit(s_hit, bone_id, flags)
	if not (s_hit.draftsman and s_hit.draftsman.id) then
		trace("actor_on_before hit, draftsman not defined")
		return
	end

	trace("actor_on_before_hit damage type %s", s_hit.type)
	last_hit = hit(s_hit)

	process_artefacts(artefact_on_before_hit_functions, s_hit, bone_id, flags)
end

function actor_on_hit_callback(obj, amount, local_direction, who, bone_index)
	if not (who and who.id) then
		trace("actor_on_hit_callback not triggered, who not defined")
		return
	end
	
	trace("actor_on_hit_callback, %s, %s, %s", obj:section(), amount, who:section())

	process_artefacts(artefact_on_hit_functions, obj, amount, who, last_hit)
end

function actor_on_before_death(whoID, flags)
	trace("actor_on_before_death triggered")

	process_artefacts(artefact_on_before_death_functions, whoID, flags)
end

function actor_on_item_buy(item)
	trace("actor_on_item_buy triggered")

	process_artefacts(artefact_on_trade_functions, item, false)
end

function actor_on_item_sell(item)
	trace("actor_on_item_sell triggered")

	process_artefacts(artefact_on_trade_functions, item, true)
end

function npc_on_before_hit(npc, s_hit, bone_id, flags)
	if not (s_hit.draftsman and s_hit.draftsman.id) then
		trace("npc_on_before hit, draftsman not defined")
		return
	end

	if s_hit.draftsman:id() ~= AC_ID then
		-- trace("npc_on_before_hit not triggered %s, %s", npc:section(), s_hit.draftsman:section())
		return
	end
	last_npc_hit = hit(s_hit)
	last_npc_hit_bone_index = bone_id

	process_artefacts(artefact_on_npc_before_hit_functions, npc, s_hit, bone_id, flags)
end

function npc_on_hit_callback(npc, amount, local_direction, who, bone_index)
	if not (who and who.id) then
		trace("on_hit_callback not triggered, who not defined")
		return
	end

	if who:id() ~= AC_ID then
		-- trace("npc_on_hit_callback not triggered %s, %s, %s", npc:section(), amount, who:section())
		return
	end

	process_artefacts(artefact_on_npc_hit_functions, npc, amount, local_direction, who, bone_index, last_npc_hit)
end

function npc_on_death_callback(npc, who)
	if not (who and who.id) then
		trace("on_death_callback not triggered, who not defined")
		return
	end

	if who:id() ~= AC_ID then
		-- trace("npc_on_death_callback not triggered %s, %s", npc:section(), who:section())
		return
	end

	process_artefacts(artefact_on_npc_death_functions, npc, who, last_npc_hit, last_npc_hit_bone_index)
end

function monster_on_before_hit(monster, s_hit, bone_id, flags)
	if not (s_hit.draftsman and s_hit.draftsman.id) then
		trace("monster_on_before hit, draftsman not defined")
		return
	end

	if s_hit.draftsman:id() ~= AC_ID then
		-- trace("monster_on_before_hit not triggered %s, %s", monster:section(), s_hit.draftsman:section())
		return
	end

	if not monster:alive() then
		trace("monster_on_before_hit not triggered, monster %s not alive anymore", monster:section())
		return
	end

	last_monster_hit = hit(s_hit)
	last_monster_hit_bone_index = bone_id

	process_artefacts(artefact_on_monster_before_hit_functions, monster, s_hit, bone_id, flags)
end

function monster_on_hit_callback(monster, amount, local_direction, who, bone_index)
	if not (who and who.id) then
		trace("on_hit_callback not triggered, who not defined")
		return
	end

	if who:id() ~= AC_ID then
		-- trace("monster_on_hit_callback not triggered %s, %s, %s", monster:section(), amount, who:section())
		return
	end

	if not monster:alive() then
		trace("monster_on_hit not triggered, monster %s not alive anymore", monster:section())
		return
	end

	process_artefacts(artefact_on_monster_hit_functions, monster, amount, local_direction, who, bone_index, last_monster_hit)
end

function monster_on_death_callback(monster, who)
	if not (who and who.id) then
		trace("on_death_callback not triggered, who not defined")
		return
	end

	if who:id() ~= AC_ID then
		-- trace("monster_on_death_callback not triggered %s, %s", monster:section(), who:section())
		return
	end

	process_artefacts(artefact_on_monster_death_functions, monster, who, last_monster_hit, last_monster_hit_bone_index)
end

function heli_on_hit_callback(heli, amount, unused, who, unused2)
	if not (who and who.id) then
		trace("on_hit_callback not triggered, who not defined")
		return
	end

	if who:id() ~= AC_ID then
		-- trace("monster_on_hit_callback not triggered %s, %s, %s", monster:section(), amount, who:section())
		return
	end

	process_artefacts(artefact_on_heli_hit_functions, heli, amount, who)
end

function on_key_press(key)
	process_artefacts(artefact_on_key_press_functions, key)
end

function on_item_drag_dropped(obj_1, obj_2, slot_from, slot_to)
	if not (obj_1 and obj_2) then 
		trace("No obj_1 or obj_2 found, o1 %s, o2 %s", obj_1 and obj_1:section(), obj_2 and obj_2:section())
		return
	end

	local sec1 = obj_1:section()
	local sec2 = obj_2:section()
	for k, v in pairs(artefact_on_item_drag_dropped_functions) do
		if type(v) == "function" then 
			if k == sec1 then
				v(db.actor, sec1, obj_1, obj_2, slot_from, slot_to)
				break
			end
			if k == sec2 then
				v(db.actor, sec2, obj_2, obj_1, slot_to, slot_from)
				break
			end
		else
			local sections = v.get_sections and v:get_sections(sec1)
			if not sections then
				sections = {[k] = true}
			end
			if sections[sec1] then
				v:func(db.actor, sec1, obj_1, obj_2, slot_from, slot_to)
				break
			end

			local sections = v.get_sections and v:get_sections(sec2)
			if not sections then
				sections = {[k] = true}
			end
			if sections[sec2] then
				v:func(db.actor, sec2, obj_2, obj_1, slot_to, slot_from)
				break
			end
		end
	end
end

function bullet_on_init(bullet)
	if bullet.parent_id == AC_ID then
		local wpn = get_object_by_id(bullet.weapon_id)
		if wpn and IsWeapon(wpn) and not IsMelee(wpn) then
			process_artefacts(artefact_bullet_on_init_functions, bullet)
		end
	end
end

function bullet_on_impact(bullet)
	if bullet.parent_id == AC_ID then
		local wpn = get_object_by_id(bullet.weapon_id)
		if wpn and IsWeapon(wpn) and not IsMelee(wpn) then
			process_artefacts(artefact_bullet_on_impact_functions, bullet)
		end
	end

	-- Add particles to bullets
	local weapon = bullet.weapon_id and get_object_by_id(bullet.weapon_id)
	if not weapon then return end

	local actor_weapon = weapon:name()
	if not check_status_effect("af_sandstone" .. actor_weapon) then
		-- trace("Sandstone, weapon %s not infused", actor_weapon)
		return
	end

	local effect = status_effects["af_sandstone" .. actor_weapon].effect
	artefact_props.af_sandstone:play_particles(effect, vector():set(bullet.position):mad(bullet.direction, -0.3))
end

function bullet_on_remove(bullet)
	if bullet.parent_id == AC_ID and IsWeapon(get_object_by_id(bullet.weapon_id)) then
		local wpn = get_object_by_id(bullet.weapon_id)
		if wpn and IsWeapon(wpn) and not IsMelee(wpn) then
			process_artefacts(artefact_bullet_on_remove_functions, bullet)
		end
	end
end

function actor_on_hud_animation_play(anm_table, obj)
	process_artefacts(artefact_on_hud_animation_play_functions, anm_table, obj)
end

-- Binder patching
artefacts_game_object_registry = {}
artefact_net_spawn = item_artefact.artefact_binder.net_spawn
item_artefact.artefact_binder.net_spawn = function(self, se_abstract)
	local res = artefact_net_spawn(self, se_abstract)
	if not res then
		return res
	end

	self.section = self.object:section()
	self.id = self.object:id()
	if artefact_binder_on_update_functions[self.section] then
		artefacts_game_object_registry[self.id] = self
	end
	return res
end

AddUniqueCall(throttle(function()
	local t = artefacts_game_object_registry
	for id, binder in pairs(t) do
		if not get_object_by_id(id) then
			if artefact_binder_on_destroy_functions[binder.section] then
				artefact_binder_on_destroy_functions[binder.section](binder)
			end
			t[id] = nil
		end
		local res = artefact_binder_on_update_functions[binder.section](binder)
		if res then t[id] = nil end
	end
end))

function actor_on_first_update()
	get_actor_psy_table()
	level.set_snd_volume(1)
	exec_console_cmd("time_factor 1")
	if level.set_music_volume then level.set_music_volume(1) end

	force_refresh_state()
	local tg_now = time_global()
	local tg_add = (tg_now - tg_lag) * 0.001
	trace("tg_now %s, tg_add %s", tg_now, tg_add)

	actor_level = level_name()
	time_factor = get_time_factor()

	for key, effect in pairs(timed_effects) do
		effect.timer = effect.timer + tg_add
	end

	for key, effect in pairs(cooldowns) do
		cooldowns[key] = cooldowns[key] + tg_add
	end

	for key, effect in pairs(status_effects) do
		effect.timer = effect.timer + tg_add
	end

	RegisterScriptCallback("actor_item_to_slot", refresh_state)
	RegisterScriptCallback("actor_item_to_belt", refresh_state)
	RegisterScriptCallback("actor_item_to_ruck", refresh_state)
	RegisterScriptCallback("actor_on_item_drop", refresh_state)
	RegisterScriptCallback("actor_on_update", actor_on_update)
	RegisterScriptCallback("actor_on_weapon_fired", actor_on_weapon_fired)
	RegisterScriptCallback("actor_on_before_hit", actor_on_before_hit)
	RegisterScriptCallback("actor_on_hit_callback", actor_on_hit_callback)
	RegisterScriptCallback("actor_on_before_death", actor_on_before_death)
	RegisterScriptCallback("actor_on_item_use", actor_on_item_use)
	RegisterScriptCallback("ActorMenu_on_item_drag_drop", on_item_drag_dropped)
	RegisterScriptCallback("npc_on_before_hit", npc_on_before_hit)
	RegisterScriptCallback("npc_on_hit_callback", npc_on_hit_callback)
	RegisterScriptCallback("npc_on_death_callback", npc_on_death_callback)
	RegisterScriptCallback("monster_on_before_hit", monster_on_before_hit)
	RegisterScriptCallback("monster_on_hit_callback", monster_on_hit_callback)
	RegisterScriptCallback("monster_on_death_callback", monster_on_death_callback)
	RegisterScriptCallback("on_before_level_changing", on_before_level_changing)
	RegisterScriptCallback("heli_on_hit_callback", heli_on_hit_callback)
	RegisterScriptCallback("on_key_press", on_key_press)

	-- 1.5.2
	if _G.CHudItem__PlayHUDMotion then
		RegisterScriptCallback("actor_on_hud_animation_play", actor_on_hud_animation_play)
	end

	-- Modded exes
	if _G.CBulletOnInit then
		RegisterScriptCallback("bullet_on_init", bullet_on_init)
	end
	if _G.CBulletOnImpact then
		RegisterScriptCallback("bullet_on_impact", bullet_on_impact)
		RegisterScriptCallback("bullet_on_remove", bullet_on_remove)
	end
end

function on_trade_started_set_values()
	artefact_props.af_fountain.cashback_triggered = false
	actor_last_money = db.actor:money()
end

function on_trade_closed_set_values()
	artefact_props.af_fountain.cashback_triggered = false
end

function ActorMenu_on_trade_started()
	on_trade_started_set_values()
	RegisterScriptCallback("actor_on_item_take", actor_on_item_buy)
	RegisterScriptCallback("actor_on_item_drop", actor_on_item_sell)
end

function ActorMenu_on_trade_closed()
	on_trade_closed_set_values()
	UnregisterScriptCallback("actor_on_item_take", actor_on_item_buy)
	UnregisterScriptCallback("actor_on_item_drop", actor_on_item_sell)
end

function on_before_level_changing()
	if check_lucifer() then
		artefact_props.af_lucifer:change_condition(random_float(-0.02, -0.025))
	end
end

function save_state(m_data)
	local t = {}
	for key, effect in pairs(timed_effects) do
		if effect.save then
			t[key] = {}
			copy_table(t[key], effect)
			t[key].effect = nil
			t[key].on_end = nil
		end
	end
	m_data.perk_based_artefacts_effects = t
	m_data.perk_based_artefacts_cooldowns = cooldowns
	m_data.perk_based_artefacts_status_effects = status_effects
	m_data.perk_based_artefacts_lucifer_condition = artefact_props.af_lucifer.condition
	m_data.perk_based_artefacts_virtual_artefacts = virtual_artefacts
	m_data.perk_based_artefacts_ui_funcs = ui_funcs
	-- m_data.perk_based_artefacts_last_time = time_elapsed
end

function load_state(m_data)
	local t = m_data.perk_based_artefacts_effects or {}
	for key, effect in pairs(t) do
		if t[key].effect_function then
			local effect = load(t[key].effect_function)
			t[key].effect = function()
				effect(unpack(t[key].effect_args))
			end
		end
		if t[key].on_end_function then
			local on_end = load(t[key].on_end_function)
			t[key].on_end = function()
				on_end(unpack(t[key].on_end_args))
			end
		end
	end
	timed_effects = t
	cooldowns = m_data.perk_based_artefacts_cooldowns or {}
	status_effects = m_data.perk_based_artefacts_status_effects or {}
	artefact_props.af_lucifer.condition = m_data.perk_based_artefacts_lucifer_condition or 1
	virtual_artefacts = m_data.perk_based_artefacts_virtual_artefacts or {}
	ui_funcs = m_data.perk_based_artefacts_ui_funcs or {}
	-- saved_time_elapsed = m_data.perk_based_artefacts_last_time or 0
end

function pbaui_on_indicator_ui_init(ui)
	RegisterScriptCallback("pbaui_on_indicator_remove", pbaui_on_indicator_remove)
	for key, t in pairs(ui_funcs) do
		ui:AddIndicator(key, t.override, t.section, t.text_func, t.validate_func, t.icon_layers)
	end
end

function on_option_change()
	if ui_mcm then
		load_settings()
		force_refresh_state()
	end
end

function on_game_start()
	trace("Registering")
	tg_lag = time_global()
	trace("tg_on_game_start %s", tg_lag)
	RegisterScriptCallback("actor_on_first_update", on_option_change)
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	RegisterScriptCallback("load_state", load_state)
	RegisterScriptCallback("save_state", save_state)
	RegisterScriptCallback("ActorMenu_on_trade_started", ActorMenu_on_trade_started)
	RegisterScriptCallback("ActorMenu_on_trade_closed", ActorMenu_on_trade_closed)
	RegisterScriptCallback("on_option_change", on_option_change)
	RegisterScriptCallback("pbaui_on_indicator_ui_init", pbaui_on_indicator_ui_init)
end

--Debug
function set_lucifer_condition(condition)
	artefact_props.af_lucifer:set_condition(condition)
end

function spawn_perk_artefacts()
	for k, v in pairs(artefact_props) do
		if v.sections then
			for sec, _ in pairs(v.sections) do
				if sec ~= "af_lucifer" then
					alife_create_item(sec, db.actor)
				end
			end
		end
	end
end

function test_replace_artefacts()
	artefact_props.af_tapeworm.sections = {af_medusa = true}
	artefact_props.af_sandstone.sections = {af_night_star = true}
end
